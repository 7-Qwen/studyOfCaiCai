{"diagram":{"elements":{"leftChildren":[],"children":[{"parent":"root","lineStyle":{"randomLineColor":"#BE49C4"},"children":[{"parent":"5303808a9e22","children":[{"parent":"3c64bca59b52","children":[{"parent":"98c4745a6c78","children":[{"parent":"ba72de8215b5","children":[],"id":"e7f5e4b8ae9f","title":"作用: 当前线程执行字节码指令的行号指示器,字节码解释器控制程序计数器的值来选取下一条要执行的字节码指令"}],"id":"ba72de8215b5","title":"程序计数器"},{"parent":"98c4745a6c78","children":[{"parent":"03249b3f84b7","children":[],"id":"f3779f0f97d0","title":"作用: 服务Java方法,方法的调用与调用完成代表着创建栈帧入栈与出栈"},{"parent":"03249b3f84b7","children":[{"parent":"a1dde99b36e2","children":[{"parent":"05bbfaee6f51","children":[],"id":"1f2bc0d1b4ee","title":"使用局部变量槽来存储局部变量(包含实参)"}],"id":"05bbfaee6f51","title":"局部变量表"},{"parent":"a1dde99b36e2","children":[{"parent":"97bb8bb358b9","children":[],"id":"7f4ef58fceda","title":"字节码指令执行时,往操作数栈中入栈,出栈数据(写入数据,读取内容)"}],"id":"97bb8bb358b9","title":"操作数栈<br>"},{"parent":"a1dde99b36e2","children":[{"parent":"c6712ac78c2d","children":[],"id":"9be48b9e0cf3","title":"动态连接: 运行时的符号引用转化为直接引用<br>"},{"parent":"c6712ac78c2d","children":[],"id":"f62275d5cbac","title":"方法返回地址: 保存信息在栈帧中,便于恢复上一层方法执行状态<br>"},{"parent":"c6712ac78c2d","children":[],"id":"434aa73c5fdb","title":"附加信息: 根据具体JVM实现,增加一些信息<br>"}],"id":"c6712ac78c2d","title":"栈帧信息<br>"}],"id":"a1dde99b36e2","title":"运行时栈帧结构"}],"id":"03249b3f84b7","title":"Java虚拟机栈"},{"parent":"98c4745a6c78","children":[{"parent":"c23dc861c9aa","children":[],"id":"ee45f121511e","title":"服务本地方法,功能与栈相同"}],"id":"c23dc861c9aa","title":"本地方法栈"}],"collapsed":true,"id":"98c4745a6c78","title":"线程私有<br>"},{"parent":"3c64bca59b52","children":[{"parent":"268a3ee81c68","children":[{"parent":"ae384e67c464","children":[],"id":"6dbdb21bdf4c","title":"作用: 存放对象实例"}],"id":"ae384e67c464","title":"堆"},{"parent":"268a3ee81c68","children":[{"parent":"79314f9b7d7b8eea","children":[],"id":"7fc3dd0a33a2918e","title":"本地内存不属于OS为JVM分配的内存，但被JVM管理"},{"parent":"79314f9b7d7b8eea","children":[{"parent":"fd2cc77fed93","children":[],"id":"25f35a9f7321","title":"作用: 存放有关类的信息,运行时常量池等"}],"id":"fd2cc77fed93","title":"方法区"},{"parent":"79314f9b7d7b8eea","children":[{"parent":"5d0616c5d9260839","children":[],"id":"73595ae96b59885f","title":"OS内存比JVM内存快，常用于频繁读写、大文件、网络NIO等"},{"parent":"5d0616c5d9260839","children":[],"id":"5af0dde503f8d32d","title":"只有full&nbsp;gc才能回收这块内存，因此使用完资源需要释放，发送内存泄漏容易导致频繁Full&nbsp;gc"}],"id":"5d0616c5d9260839","title":"直接内存"}],"id":"79314f9b7d7b8eea","title":"本地内存"}],"collapsed":false,"id":"268a3ee81c68","title":"线程共享"}],"collapsed":true,"id":"3c64bca59b52","title":"运行时数据区"},{"parent":"5303808a9e22","children":[{"parent":"af9ee5ac7734","children":[{"parent":"c0042d3b6e01","children":[],"id":"98e18a738733","title":"栈溢出: 线程请求栈深度 &gt; JVM允许深度<br>"},{"parent":"c0042d3b6e01","children":[{"parent":"6935603111e2","children":[],"id":"e9c8b208c05c","title":"栈扩展无法申请到足够空间 (HotSpot中不存在)<br>"},{"parent":"6935603111e2","children":[{"parent":"3d25e8b85794","children":[],"id":"538e51f86e4c","title":"1. JVM算一个进程,操作系统为进程分配的内存(A)是有上限的"},{"parent":"3d25e8b85794","children":[],"id":"1d3eaff837dd","title":"2. 这个内存大部分是堆内存(B),部分为方法区(C),部分为程序计数器以及其他等等(D),那栈分到的内存(E=A-B-C-D)"},{"parent":"3d25e8b85794","children":[],"id":"2582d4fc183e","title":"3. 此时如果大量创建线程,创建线程无法申请到足够内存就OOM"}],"id":"3d25e8b85794","title":"创建线程无法申请到足够空间<br>"}],"id":"6935603111e2","title":"OOM<br>"}],"id":"c0042d3b6e01","title":"栈"},{"parent":"af9ee5ac7734","children":[{"parent":"f3c370f7ba61","children":[],"id":"0dbf165d6af3","title":"OOM :&nbsp; 无法为新对象申请足够的内存<br>"}],"id":"f3c370f7ba61","title":"堆"},{"parent":"af9ee5ac7734","children":[{"parent":"17edebec9dc0","children":[],"id":"bc54325e4f3b","title":"OOM: 运行时产生大量动态类<br>"}],"id":"17edebec9dc0","title":"方法区"},{"parent":"af9ee5ac7734","children":[{"parent":"37e1b9af5412","children":[],"id":"beeea0ffb59d","title":"OOM: 无法申请到足够的直接内存(不会真正的向操作系统提出申请内存,这个异常是JVM手动抛出的)<br>"}],"id":"37e1b9af5412","title":"直接内存"}],"collapsed":true,"id":"af9ee5ac7734","title":"内存溢出异常"},{"parent":"5303808a9e22","children":[{"parent":"e1376832a791","children":[{"parent":"f161ee89127d","children":[{"parent":"696c6015cff0","children":[],"id":"a3868a0311be","title":"HotSpot遇到new指令,去常量池中找到这个类的符号引用,检查这个类是否进行过类加载(父类也需要检查)"}],"id":"696c6015cff0","title":"类加载检查"},{"parent":"f161ee89127d","children":[{"parent":"c089515b4f7f","children":[{"parent":"782f0f9360f9","children":[{"parent":"86e8fb0d5f86","children":[],"id":"29d1fffd32d7","title":"使用场景: 内存整齐<br>"},{"parent":"86e8fb0d5f86","children":[{"parent":"6c2304977ab9","children":[],"id":"6c4e8c60e02f","title":"1.把使用过的内存放一边,空间的内存放另一边,中间有分界指针"},{"parent":"6c2304977ab9","children":[],"id":"18c345a44ae7","title":"2. 为新对象分配内存时,把新对象放在使用过的内存那一边,然后分界指针向空间内存那边移动这个新对象内存的距离"}],"id":"6c2304977ab9","title":"过程: <br>"},{"parent":"86e8fb0d5f86","children":[],"id":"f040c84d8769","title":"特点: 简单,高效,需要收集器有整理的能力<br>"}],"id":"86e8fb0d5f86","title":"指针碰撞"},{"parent":"782f0f9360f9","children":[{"parent":"2f246c91edf3","children":[],"id":"11c3bea10591","title":"使用场景: 已使用内存与空闲内存交错在一起<br>"},{"parent":"2f246c91edf3","children":[],"id":"2c9c2acfc40c","title":"过程: 维护一个列表,记录哪些内存空闲,分配时为新对象找一个块容量足够大的内存,更新空闲列表<br>"},{"parent":"2f246c91edf3","children":[],"id":"0f0f00501c3d","title":"特点: 比指针碰撞复杂,不需要收集器有整理能力<br>"}],"id":"2f246c91edf3","title":"空闲列表"}],"id":"782f0f9360f9","title":"分配方式"},{"parent":"c089515b4f7f","children":[{"parent":"d875327b94dd","children":[],"id":"81c51168f81f","title":"问题: 多个线程同时想将一块内存分配给自己线程中的xx对象"},{"parent":"d875327b94dd","children":[{"parent":"c109dc64b040","children":[],"id":"82670e722999","title":"CAS+失败重试保证操作原子性"},{"parent":"c109dc64b040","children":[{"parent":"ce6ce003e837","children":[],"id":"ab00835af585","title":"1. 给个线程在内存上分配一小块内存(TLAB)<br>"},{"parent":"ce6ce003e837","children":[],"id":"00a41adf4980","title":"2. 为对象分配内存时先在该线程本地缓冲区上分配"},{"parent":"ce6ce003e837","children":[],"id":"ae9ca8679742","title":"3. 如果线程的本地缓冲区不够了,才需要同步(CAS+失败重试)<br>"}],"id":"ce6ce003e837","title":"(Thread Local Allocation Buffer )TLAB本地线程分配缓存<br>"}],"id":"c109dc64b040","title":"解决方案"}],"id":"d875327b94dd","title":"并发分配内存"}],"id":"c089515b4f7f","title":"分配内存"},{"parent":"f161ee89127d","children":[],"id":"0620a971a1ba","title":"初始化零值: 保证成员变量未初始化就可以使用"},{"parent":"f161ee89127d","children":[{"parent":"42b5d29e3048","children":[],"id":"e4683f888896","title":"把信息存放在对象头(哈希码,分代年龄,锁状态等...)"}],"id":"42b5d29e3048","title":"设置对象头"},{"parent":"f161ee89127d","children":[{"parent":"64c1773f489c","children":[],"id":"33021a92046f","title":"执行init方法(实例代码块、构造器)<br>"}],"id":"64c1773f489c","title":"初始化 <br>"}],"collapsed":false,"id":"f161ee89127d","title":"对象的创建"},{"parent":"e1376832a791","children":[{"parent":"4a066571998a","children":[{"parent":"43bda750b7ea","children":[],"id":"46da7cc21072","title":"Mark Word（8 Byte）: 对象自身运行时数据（哈希码，分代年龄，锁状态）<br>"},{"parent":"43bda750b7ea","children":[],"id":"409001029a50","title":"类型指针（4 Byte）: 指向对象类型元数据的指针(该对象是哪个类)<br>"},{"parent":"43bda750b7ea","children":[],"id":"451101c87c49","title":"如果对象是数组还需要记录数组长度（4 Byte）"}],"id":"43bda750b7ea","title":"对象头"},{"parent":"4a066571998a","children":[{"parent":"85e85047af98","children":[],"id":"0a2f8088c28a","title":"记录父类继承的字段和该类声明的字段<br>"}],"id":"85e85047af98","title":"实例数据"},{"parent":"4a066571998a","children":[{"parent":"0be95ad21d56","children":[],"id":"4a1f40f73d2e","title":"HotSpot要求对象大小必须为8字节的整倍数,未达到8字节整倍数对象对齐填充"}],"id":"0be95ad21d56","title":"对齐填充 <br>"}],"collapsed":true,"id":"4a066571998a","title":"对象的内存布局"},{"parent":"e1376832a791","children":[{"parent":"96faa36e4ec5","children":[],"id":"4f1851c4c8ec","title":"通过栈上的reference类型操作堆上对象"},{"parent":"96faa36e4ec5","children":[{"parent":"03ca878872b3","children":[{"parent":"145a01db71a6","children":[],"id":"0f416ea7185b","title":"过程: reference存储的是堆中的句柄池的该对象地址,句柄池中的句柄包含对象实例数据地址和对象类型数据<br>"},{"parent":"145a01db71a6","children":[],"id":"326cf581cd3f","title":"优点: 稳定,改动时只需要改动句柄的对象实例数据<br>"},{"parent":"145a01db71a6","children":[],"id":"ffd260cbb978","title":"缺点: 多一次间接访问开销<br>"}],"id":"145a01db71a6","title":"句柄访问(间接)"},{"parent":"03ca878872b3","children":[{"parent":"2d0667af99b8","children":[],"id":"3c89b8adc681","title":"过程: reference存储的是该对象在堆内存中的地址(对象的内存布局需要记录对象类型信息,比如对象头中的类型指针)<br>"},{"parent":"2d0667af99b8","children":[],"id":"bc8023fc46c9","title":"优点: 速度快<br>"},{"parent":"2d0667af99b8","children":[],"id":"cef87529e1f5","title":"缺点: 改动时需要改动reference存储的地址<br>"}],"id":"2d0667af99b8","title":"直接指针访问(直接,HotSpot主要使用)<br>"}],"id":"03ca878872b3","title":"访问"}],"collapsed":true,"id":"96faa36e4ec5","title":"对象的访问定位"}],"collapsed":true,"id":"e1376832a791","title":"关于对象"}],"id":"5303808a9e22","title":"内存管理篇"},{"parent":"root","lineStyle":{"randomLineColor":"#3D5EC2"},"children":[{"parent":"3ce183057d16","children":[{"parent":"0a190bff418a","children":[],"id":"54a6ece4a795","title":"魔数:确定这个文件是否为一个能被虚拟机识别的Class文件"},{"parent":"0a190bff418a","children":[],"id":"1164b11155a9","title":"主,次版本号:虚拟机拒绝执行超过其版本号的Class文件"},{"parent":"0a190bff418a","children":[{"parent":"73d6bccfa69a","children":[],"id":"9a7b28a5c57e","title":"字面量:文本字符串,被final声明的常量"},{"parent":"73d6bccfa69a","children":[{"parent":"6fd3c3564730","children":[],"id":"f37e73e44953","title":"简单名称: 没用描述性修饰的字段或方法的名称<br>"},{"parent":"6fd3c3564730","children":[{"parent":"ee3518d170c0","children":[],"id":"013d8e232c2f","title":"字段描述符: 描述字段类型<br>"},{"parent":"ee3518d170c0","children":[],"id":"7690da25bead","title":"方法描述符: 描述参数类型,个数,返回值<br>"}],"id":"ee3518d170c0","title":"描述符<br>"}],"id":"6fd3c3564730","title":"符号引用:全限定名,方法,字段名,描述符等"}],"id":"73d6bccfa69a","title":"常量池"},{"parent":"0a190bff418a","children":[],"id":"75948b69a980","title":"访问标识: 识别类的访问信息<br>"},{"parent":"0a190bff418a","children":[],"id":"6b61dced79db","title":"类索引:确定本类的全限定名"},{"parent":"0a190bff418a","children":[],"id":"64ce0b75dcd2","title":"父类索引:确定父类的全限定名"},{"parent":"0a190bff418a","children":[],"id":"870c43116f9c","title":"接口索引集合: 描述这个类实现了哪些接口<br>"},{"parent":"0a190bff418a","children":[],"id":"6085060c358c","title":"字段表集合: 描述类声明字段(不会列出继承的字段)<br>"},{"parent":"0a190bff418a","children":[],"id":"282dd3ed9a0f","title":"方法表集合:描述类声明的方法(不会列出继承的方法)"},{"parent":"0a190bff418a","children":[{"parent":"ed583ab2c6cd","children":[],"id":"dc003c6fe8e1","title":"Code(方法中出现): 存储方法中的代码编译后的字节码指令<br>"},{"parent":"ed583ab2c6cd","children":[],"id":"fc61175312ba","title":"ConstantValue: 类加载准备阶段为常量赋值<br>"}],"id":"ed583ab2c6cd","title":"属性表集合: 描述某些场景的专有信息(特别多)<br>"}],"collapsed":true,"id":"0a190bff418a","title":"类文件结构"},{"parent":"3ce183057d16","children":[{"parent":"3f970c7a2e60","children":[{"parent":"faee62b04193","children":[{"parent":"6a3830382278","children":[],"id":"0130e8dc88cc","title":"1.通过这个类的全限定名在常量池中找到它的符号引用"},{"parent":"6a3830382278","children":[],"id":"c39539ccd4a4","title":"2.把这个类静态存储结构 转化为 方法区的运行时数据结构"},{"parent":"6a3830382278","children":[],"id":"cc381bd9bb10","title":"3.在堆中生成这个类的Class对象,通过Class对象访问方法区的类信息"}],"collapsed":true,"id":"6a3830382278","title":"加载"},{"parent":"faee62b04193","children":[{"parent":"943e63212d68","children":[{"parent":"7ca28adba4ac","children":[],"id":"0f11b3bbafdb","title":"文件格式验证: 验证字节流是否符合Class文件格式规范<br>"},{"parent":"7ca28adba4ac","children":[],"id":"581651d23e3b","title":"元数据验证: 对类的元数据信息进行验证(对这个类与其他类间关系的验证)<br>"},{"parent":"7ca28adba4ac","children":[],"id":"3befe34e5fc2","title":"字节码验证: 对字节码进行验证,保证此类在运行时不会做出对JVM危险行为<br>"},{"parent":"7ca28adba4ac","children":[],"id":"5c91da677f36","title":"符号引用验证: 保证符号引用解析为直接引用时,此类不缺少它所依赖的资源<br>"}],"collapsed":true,"id":"7ca28adba4ac","title":"验证: 确保类信息安全,不危害JVM<br>"},{"parent":"943e63212d68","children":[{"parent":"5ed080a83fa9","children":[{"parent":"a10d397fb0bd","children":[],"id":"250eb462b7d8","title":"逻辑上: 在方法区为类变量分配内存<br>"},{"parent":"a10d397fb0bd","children":[],"id":"e5ec0555de7c","title":"实际上: JDK7把字符串常量池,类变量挪出永久代放在堆中<br>"}],"id":"a10d397fb0bd","title":"分配内存<br>"},{"parent":"5ed080a83fa9","children":[{"parent":"9ddedc80a06f","children":[],"id":"44a6b8f9e137","title":"普通类变量: 默认赋该类型的零值<br>"},{"parent":"9ddedc80a06f","children":[],"id":"e389f17c4039","title":"被final修饰且ConstantValue指向常量池中的值是基本类型或字符串 的类变量: 默认赋ConstantValue指向常量池的值<br>"}],"id":"9ddedc80a06f","title":"默认赋值"}],"collapsed":true,"id":"5ed080a83fa9","title":"准备:为静态变量分配内存并默认赋值"},{"parent":"943e63212d68","children":[{"parent":"d6c369f0e1ce","children":[{"parent":"1e49a58b5d8e","children":[],"id":"e66575fefcdb","title":"1. 把要解析的类符号引用交给当前类的类加载器去加载"},{"parent":"1e49a58b5d8e","children":[],"id":"e048c8c65075","title":"2. 解析前要符号引用验证,如果所在类没权限访问这个要解析的类抛出IllegalAccessError异常<br>"}],"id":"1e49a58b5d8e","title":"类和接口的解析"},{"parent":"d6c369f0e1ce","children":[{"parent":"595e085c8759","children":[],"id":"d7f29b25356c","title":"1.先对该字段的类(类,抽象类,接口)进行解析"},{"parent":"595e085c8759","children":[{"parent":"eb94c5cde625","children":[],"id":"1220ec194074","title":"如果所属类有父类或实现了接口,会自下而上的寻找"},{"parent":"eb94c5cde625","children":[],"id":"7753576249b7","title":"找不到抛出NoSuchFiledError"}],"id":"eb94c5cde625","title":"2. 在所属类中查找该字段简单名称和描述符都匹配的字段,返回它的直接引用<br>"},{"parent":"595e085c8759","children":[],"id":"40b2647f1a11","title":"3. 对此字段解析权限验证 (没有权限抛出IllegaAccessError异常)<br>"}],"id":"595e085c8759","title":"字段的解析"},{"parent":"d6c369f0e1ce","children":[{"parent":"199d4aaf9df7","children":[],"id":"35e0b8eaa0f1","title":"1. 先对该方法的类(类,抽象类,接口)进行解析"},{"parent":"199d4aaf9df7","children":[{"parent":"8aae6f2bac1c","children":[],"id":"019bb293c2aa","title":"2.1 如果所属类是接口抛出IncompatibleClassChangeError异常<br>"},{"parent":"8aae6f2bac1c","children":[],"id":"7af1dc25d47d","title":"2.2 如果所属类有父类或实现了接口,会自下而上的寻找(先父类再接口)<br>"},{"parent":"8aae6f2bac1c","children":[{"parent":"5bcc60d9b6e4","children":[],"id":"c91382de6da0","title":"本身找不到,父类也找不到,在接口中找到了,所以所属类为抽象类"}],"id":"5bcc60d9b6e4","title":"2.3 如果在接口中找到了,说明所属类是抽象类,抛出AbstractMethodError异常<br>"},{"parent":"8aae6f2bac1c","children":[],"id":"39332f787426","title":"2.4 找不到抛出NoSuchMethodError<br>"}],"id":"8aae6f2bac1c","title":"2. 在所属类中查找该方法简单名称和描述符都匹配的方法,返回它的直接引用<br>"}],"id":"199d4aaf9df7","title":"方法的解析"},{"parent":"d6c369f0e1ce","children":[{"parent":"9101db8a1034","children":[],"id":"0787f79e19cf","title":"1.先对该方法的类进行(类,抽象类,接口)解析"},{"parent":"9101db8a1034","children":[],"id":"aab57981e17d","title":"2.在所属接口中查找该接口方法简单名称和描述符都匹配的接口方法,返回它的直接引用"}],"id":"9101db8a1034","title":"接口方法的解析"}],"collapsed":true,"id":"d6c369f0e1ce","title":"解析:将常量池的符号引用替换为直接引用"}],"collapsed":false,"id":"943e63212d68","title":"连接<br>"},{"parent":"faee62b04193","children":[{"parent":"ebfe7eaa451b","children":[{"parent":"e6636476a9fd","children":[{"parent":"692fe53a39e0","children":[],"id":"eacabd1a9565","title":"new"},{"parent":"692fe53a39e0","children":[],"id":"5caaa5ae5ebf","title":"读写静态变量"},{"parent":"692fe53a39e0","children":[],"id":"4ca40c8172b3","title":"调用静态方法<br>"}],"id":"692fe53a39e0","title":"1.遇到new,getstatic,putstatic,invokestatic字节码指令"},{"parent":"e6636476a9fd","children":[],"id":"12bafafbf47e","title":"2. 使用java.lang.reflect反射包下的方法对类型进行反射<br>"},{"parent":"e6636476a9fd","children":[],"id":"733ed2a1ddca","title":"3.父类未初始化要初始化父类<br>"},{"parent":"e6636476a9fd","children":[],"id":"c59c656f2b4d","title":"4. VM启动时, 先初始化main所在的类<br>"},{"parent":"e6636476a9fd","children":[],"id":"43891413ca68","title":"5. 某类实现的接口中有默认方法,要先对接口进行初始化<br>"},{"parent":"e6636476a9fd","children":[],"id":"f48685b4a10e","title":"6. 动态语言支持...<br>"}],"collapsed":true,"id":"e6636476a9fd","title":"主动引用(必须初始化)<br>"},{"parent":"ebfe7eaa451b","children":[{"parent":"13636c809b42","children":[],"id":"0764bf039d4b","title":"1. 子类访问父类静态变量(父类初始化,子类不初始化)"},{"parent":"13636c809b42","children":[],"id":"cfc5225e3c4a","title":"2. 实例化数组（虚拟机自动创建一个管理数组的类进行初始化）<br>"},{"parent":"13636c809b42","children":[],"id":"665f23afb204","title":"3. 调用静态常量<br>"}],"collapsed":true,"id":"13636c809b42","title":"被动引用(不用初始化)"},{"parent":"ebfe7eaa451b","children":[],"id":"74d38a5c9b88","title":"&lt;cinit&gt;是编译器自动收集给类变量赋值的动作和静态代码块合并生成的<br>"}],"id":"ebfe7eaa451b","title":"初始化 : 执行&lt;cinit&gt;类构造器<br>"}],"collapsed":false,"id":"faee62b04193","title":"类加载阶段"},{"parent":"3f970c7a2e60","children":[{"parent":"9f1bd532c45f","children":[],"id":"aa4e1bc1cea9","title":"类加载器的作用: 在加载阶段,通过类的全限定名获取该类的二进制字节流<br>"},{"parent":"9f1bd532c45f","children":[{"parent":"9fc3983a6d42","children":[{"parent":"42395fb65c5d","children":[],"id":"4b349293bcd5","title":"加载核心类库&lt;JAVA_HOME&gt;\\lib "},{"parent":"42395fb65c5d","children":[],"id":"0392fd7041a8","title":"C++编写的,无法直接获得"}],"id":"42395fb65c5d","title":"启动(引导)类加载器 Bootstrap Classloader<br>"},{"parent":"9fc3983a6d42","children":[{"parent":"8418852057bf","children":[],"id":"aa683d07934e","title":"加载扩展库 &lt;JAVA_HOME&gt;\\lib\\ext\\*.jar<br>"}],"id":"8418852057bf","title":"扩展类加载器 Extension Classloader<br>"},{"parent":"9fc3983a6d42","children":[{"parent":"9a00b3390ab2","children":[],"id":"579ec133d029","title":"加载我们自己在程序中自定义的类"}],"id":"9a00b3390ab2","title":"应用程序(系统)类加载器 App(System) Classloader<br>"},{"parent":"9fc3983a6d42","children":[{"parent":"d5ff9535c5f6","children":[],"id":"50751a030671","title":"实现ClassLoader类,重写findClass方法"}],"collapsed":false,"id":"d5ff9535c5f6","title":"自定义类加载器 <br>"}],"collapsed":false,"id":"9fc3983a6d42","title":"类加载器种类"},{"parent":"9f1bd532c45f","children":[{"parent":"1d954de69f6c","children":[{"parent":"4190ebc688ca","children":[],"id":"c1e687e50cd3","title":"1. 检查这个类是否加载过了<br>"},{"parent":"4190ebc688ca","children":[],"id":"eb325b34d57c","title":"2. 如果没加载过,检查有没有父类加载器,如果有则交给父类加载器加载<br>"},{"parent":"4190ebc688ca","children":[],"id":"260a5934ab82","title":"3.&nbsp; 如果父类构造器为空,说明递归到BootStrapClassloader了,交给启动类加载器加载<br>"},{"parent":"4190ebc688ca","children":[],"id":"ced6b9f563f8","title":"4. 如果无法加载抛出异常交给子类加载器去加载<br>"}],"id":"4190ebc688ca","title":"过程"},{"parent":"1d954de69f6c","children":[],"id":"d0e2d2b5f40f","title":"加载顺序: 启动类加载器-&gt;扩展类加载器-&gt;系统类加载器-&gt;自定义类加载器<br>"},{"parent":"1d954de69f6c","children":[],"id":"a273500ed333","title":"作用: 防止重复加载同一个Class,核心类不能被篡改<br>"}],"id":"1d954de69f6c","title":"双亲委派模型"}],"collapsed":false,"id":"9f1bd532c45f","title":"类加载器"}],"collapsed":true,"id":"3f970c7a2e60","title":"类加载机制"},{"parent":"3ce183057d16","children":[{"parent":"06a269df325f","children":[],"id":"0cbc3977298c","title":"作用: 确定要调用哪个方法<br>"},{"parent":"06a269df325f","children":[{"parent":"fee759c649c8","children":[],"id":"a977cfcdd5a1","title":"编译期间就确定了要调用哪个方法,运行时不可改变"},{"parent":"fee759c649c8","children":[{"parent":"2ddb402033f6","children":[],"id":"0c73fa6f9b2d","title":"静态方法,私有方法,父类方法,被final修饰方法,实例构造器"}],"id":"2ddb402033f6","title":"调用非虚方法"}],"id":"fee759c649c8","title":"解析调用(静态解析)"},{"parent":"06a269df325f","children":[{"parent":"fab0be8496de","children":[],"id":"7b5e920ea056","title":"(静态类型)Object obj = new Object() (实际类型)"},{"parent":"fab0be8496de","children":[{"parent":"0ccdbd2e6f4d","children":[],"id":"3ec89da31cd5","title":"调用不属于非虚方法的方法<br>"}],"id":"0ccdbd2e6f4d","title":"调用虚方法"},{"parent":"fab0be8496de","children":[{"parent":"ec1638748779","children":[],"id":"4ad96a875faf","title":"根据编译期间的静态类型决定方法执行版本的分派"},{"parent":"ec1638748779","children":[],"id":"9d35032ac4f7","title":"特殊的解析调用,发生在编译期"},{"parent":"ec1638748779","children":[],"id":"5ed1d7180ada","title":"典型表现: 重载<br>"}],"id":"ec1638748779","title":"静态分派"},{"parent":"fab0be8496de","children":[{"parent":"bbb053fdb486","children":[],"id":"99f0dcafa7fa","title":"根据动态期间的实际类型决定方法执行版本的分派"},{"parent":"bbb053fdb486","children":[],"id":"ce5cc046d376","title":"典型表现: 重写<br>"},{"parent":"bbb053fdb486","children":[{"parent":"899be6b1133e","children":[],"id":"75372408666e","title":"1. invokevirtual找到栈顶元素的实际类型<br>"},{"parent":"899be6b1133e","children":[],"id":"0d1579fe8914","title":"2. 如果能在实际类型中找到与常量池中简单名称与描述符都匹配的方法<br>"},{"parent":"899be6b1133e","children":[],"id":"dcee3cc3a96a","title":"3. 进行权限验证,通过则返回,未通过验证则抛出IllegalAccessException异常<br>"},{"parent":"899be6b1133e","children":[],"id":"cdd33ed5c205","title":"4. 如果在实际类型中没找到就去父类中找,没找到抛出AbstracMethodError<br>"}],"id":"899be6b1133e","title":"使用invokevirtual指令执行"}],"id":"bbb053fdb486","title":"动态分派"},{"parent":"fab0be8496de","children":[],"id":"947bc7819239","title":"宗量: 方法参数与方法调用者<br>"},{"parent":"fab0be8496de","children":[],"id":"9703b60377d5","title":"多分派: 根据多个宗量选择方法(静态分派)<br>"},{"parent":"fab0be8496de","children":[],"id":"d2c9a4f31cf0","title":"单分派: 根据单个宗量选择方法(动态分派)<br>"}],"id":"fab0be8496de","title":"分派调用(动态调用)"}],"collapsed":true,"id":"06a269df325f","title":"方法调用"},{"parent":"3ce183057d16","children":[{"parent":"0de63415ca21","children":[{"parent":"8bf23d66ca0e","children":[{"parent":"6697823449fe","children":[{"parent":"a405fbfe6c34","children":[{"parent":"572cf1c29a42","children":[],"id":"694718fa67c5","title":"1. 字符流转换为标记（token）流"},{"parent":"572cf1c29a42","children":[],"id":"2c65fb5be374","title":"2. token流转为抽象语法树"},{"parent":"572cf1c29a42","children":[],"id":"1cdbeaa4aade","title":"3. 填充符号表的符号信息与地址"}],"id":"572cf1c29a42","title":"解析与符号填充"},{"parent":"a405fbfe6c34","children":[{"parent":"050bdaf9454f","children":[],"id":"3728933cb1b7","title":"4. 注解处理器处理特殊注解"}],"id":"050bdaf9454f","title":"处理注解"},{"parent":"a405fbfe6c34","children":[{"parent":"8fc3431b6f0b","children":[],"id":"eb4902a2c870","title":"5. 检测语义信息"},{"parent":"8fc3431b6f0b","children":[],"id":"e7afce44b45c","title":"6. 解语法糖"},{"parent":"8fc3431b6f0b","children":[],"id":"910924920862","title":"7. 生成（类）初始化方法（init,cinit）"},{"parent":"8fc3431b6f0b","children":[],"id":"be870e9665e4","title":"8. 生成字节码文件"}],"id":"8fc3431b6f0b","title":"语义分析与生成字节码"}],"id":"a405fbfe6c34","title":"Java源代码编译成字节码文件过程"}],"id":"6697823449fe","title":"前端编译器"},{"parent":"8bf23d66ca0e","children":[{"parent":"6945790ead6a","children":[{"parent":"430dd5d55f7f","children":[{"parent":"4443106fd87c","children":[],"id":"70906ad1ba5d","title":"编译器直接将调用的方法编译到方法体"}],"id":"4443106fd87c","title":"方法内联"},{"parent":"430dd5d55f7f","children":[{"parent":"e89b8b8c3e32","children":[],"id":"54882f5ba1f2","title":"公共子表达式计算过（没有变）就不用再计算了直接用"}],"id":"e89b8b8c3e32","title":"公共子表达式消除"},{"parent":"430dd5d55f7f","children":[],"id":"b836892c8854","title":"数组范围检查消除"}],"id":"430dd5d55f7f","title":"client C1"},{"parent":"6945790ead6a","children":[{"parent":"b5f6f7ef2a2c","children":[{"parent":"c65bad6f548d","children":[],"id":"2429cb68d1d4","title":"发生逃逸：对象在某个方法中，但是作用域可以在这个方法外"},{"parent":"c65bad6f548d","children":[],"id":"a19f1b3fc610","title":"不发生逃逸：对象在某个方法中，作用域只在这个方法中"}],"id":"c65bad6f548d","title":"逃逸"},{"parent":"b5f6f7ef2a2c","children":[{"parent":"a2bc20f14be1","children":[{"parent":"3303bce1e229","children":[],"id":"612c6979fac5","title":"不发生逃逸，将聚合量（对象）使用标量（它的属性）替换"}],"id":"3303bce1e229","title":"标量替换"},{"parent":"a2bc20f14be1","children":[{"parent":"8321e8eb9906","children":[],"id":"bdf68f0f42fb","title":"检测到线程安全就不会加锁"}],"id":"8321e8eb9906","title":"锁消除"},{"parent":"a2bc20f14be1","children":[{"parent":"c33b59b05a8e","children":[],"id":"ea4279be91b0","title":"局部对象直接在栈上分配内存"}],"id":"c33b59b05a8e","title":"栈上分配"}],"id":"a2bc20f14be1","title":"逃逸分析带来的优化"}],"id":"b5f6f7ef2a2c","title":"client C2&nbsp;"}],"collapsed":true,"id":"6945790ead6a","title":"即时编译器JIT"}],"collapsed":false,"id":"8bf23d66ca0e","title":"编译器"},{"parent":"0de63415ca21","children":[{"parent":"2bbb86d4e185","children":[{"parent":"a467364b51f0","children":[],"id":"02fc0d2fd76f","title":"字节码解释器"},{"parent":"a467364b51f0","children":[],"id":"158666d86578","title":"即时编译器"},{"parent":"a467364b51f0","children":[],"id":"dea749714a60","title":"垃圾回收器"}],"id":"a467364b51f0","title":"组成"},{"parent":"2bbb86d4e185","children":[{"parent":"3cb4e23f3484","children":[],"id":"0af837eef3ca","title":"程序刚运行，先使用字节码解释器，将程序计数器指示的字节码解释为机器码；程序运行一段时间后，由JIT将热点代码编译为机器码并存储在方法区的code cache，提高运行速度；同时GC在此过程中清理不再使用的对象"}],"id":"3cb4e23f3484","title":"执行过程"}],"collapsed":true,"id":"2bbb86d4e185","title":"执行引擎"}],"collapsed":true,"id":"0de63415ca21","title":"编译器与执行引擎"}],"id":"3ce183057d16","title":"字节码与类加载篇"},{"parent":"root","lineStyle":{"randomLineColor":"#DD489D"},"children":[{"parent":"d6981a1574d4","children":[{"parent":"e4825647c15b","children":[{"parent":"6c2de5602450","children":[],"id":"7f774a07d820","title":"申请发生Full&nbsp;GC&nbsp;但不一定成功"}],"id":"6c2de5602450","title":"System.gc()&nbsp;"},{"parent":"e4825647c15b","children":[{"parent":"3d66bd7f87cf","children":[],"id":"313993ea5d56","title":"申请内存不够，发生OOM"}],"id":"3d66bd7f87cf","title":"内存溢出"},{"parent":"e4825647c15b","children":[{"parent":"45328eb09a75","children":[{"parent":"35e6bccbb458","children":[],"id":"c449108a920f","title":"不正确的延长对象的生命周期"},{"parent":"35e6bccbb458","children":[],"id":"d9850a006bb8","title":"未关闭资源"}],"id":"35e6bccbb458","title":"不再使用的引用无法回收，最终可能导致资源耗尽内存溢出"}],"id":"45328eb09a75","title":"内存泄漏"},{"parent":"e4825647c15b","children":[{"parent":"1d007b05522e","children":[],"id":"77d6b0da9f04","title":"GC线程分析垃圾时需要暂停用户线程（用户线程改动引用可能导致分析错误）"},{"parent":"1d007b05522e","children":[],"id":"d6be38d8595b","title":"GC线程可以与用户线程并发执行，需要使用增量更新/原始快照解决对象消失问题"}],"id":"1d007b05522e","title":"Stop the word (STW)"},{"parent":"e4825647c15b","children":[{"parent":"0e1abad52254","children":[{"parent":"1f5224234614","children":[],"id":"217c940b194c","title":"平时new的都是强引用"},{"parent":"1f5224234614","children":[],"id":"bb76fd2e80ea","title":"GC时回收不可达的强引用"}],"id":"1f5224234614","title":"强引用"},{"parent":"0e1abad52254","children":[{"parent":"46a9f1fcae01","children":[],"id":"f661f8c809ae","title":"SoftReference"},{"parent":"46a9f1fcae01","children":[],"id":"08e95671b50b","title":"空间不足时，软引用还在使用，Full GC回收"},{"parent":"46a9f1fcae01","children":[],"id":"4bdbe05a311b","title":"软引用可以做缓存"}],"id":"46a9f1fcae01","title":"软引用"},{"parent":"0e1abad52254","children":[{"parent":"66b6cfbec704","children":[],"id":"474c00f9a8c7","title":"WeakReference"},{"parent":"66b6cfbec704","children":[],"id":"77bb50085a95","title":"只要发生GC弱引用就会被回收"},{"parent":"66b6cfbec704","children":[],"id":"822c80b98029","title":"weakHashMap Key是弱引用，K不用时KV会删除"}],"id":"66b6cfbec704","title":"弱引用"},{"parent":"0e1abad52254","children":[{"parent":"208e75ae1fa9","children":[],"id":"19f3e3818f54","title":"虚引用PhantomReference搭配引用队列ReferenceQueue使用"},{"parent":"208e75ae1fa9","children":[],"id":"d526e265149d","title":"不能拿到虚引用对象实例，当虚引用被回收时，通过引用队列发送通知告知被回收了"},{"parent":"208e75ae1fa9","children":[],"id":"b48caf1cd51e","title":"GC只回收堆内存，当有直接内存不使用时可以回收虚引用，通过引用队列告诉JVM去回收直接内存"}],"id":"208e75ae1fa9","title":"虚引用"}],"collapsed":false,"id":"0e1abad52254","title":"引用"}],"collapsed":true,"id":"e4825647c15b","title":"基本概念"},{"parent":"d6981a1574d4","children":[{"parent":"7e8bae393f89","children":[{"parent":"eca023bbe002","children":[],"id":"e3bdfaa20ce9","title":"优：简单"},{"parent":"eca023bbe002","children":[],"id":"bb10a709e97b","title":"缺: 无法解决循环引用"}],"id":"eca023bbe002","title":"引用计数法"},{"parent":"7e8bae393f89","children":[{"parent":"aea90bb4569b","children":[],"id":"c2e319e0b12a","title":"优：可以解决循环引用"},{"parent":"aea90bb4569b","children":[],"id":"d8aabdb47376","title":"缺：使用可达性分析算法需要保持一致性快照（STW会让用户线程停止）"},{"parent":"aea90bb4569b","children":[],"id":"4b78acd76eb9","title":"过程: 从根节点对象（GC Roots）开始遍历引用链，能到达说明可达，未到达说明是垃圾"},{"parent":"aea90bb4569b","children":[{"parent":"d65dc3e3cace","children":[],"id":"3b1e191475e2","title":"栈帧中局部变量表引用的对象"},{"parent":"d65dc3e3cace","children":[],"id":"1cc2ab8c9478","title":"方法区类变量引用的对象"},{"parent":"d65dc3e3cace","children":[],"id":"2572646104af","title":"方法区常量引用的对象"},{"parent":"d65dc3e3cace","children":[],"id":"3115a902c67f","title":"锁对象（synchronized）"},{"parent":"d65dc3e3cace","children":[],"id":"9d14cd9f8e53","title":"JVM内部对象"}],"id":"d65dc3e3cace","title":"可以成为根节点的对象"}],"id":"aea90bb4569b","title":"可达性分析算法"},{"parent":"7e8bae393f89","children":[{"parent":"ebe871a7f7cb","children":[{"parent":"17fd9a3db3c3","children":[],"id":"868c188730fa","title":"1. 引用链不可达（它是不可达对象）"},{"parent":"17fd9a3db3c3","children":[],"id":"89d1055f25c3","title":"2. 当条件1成立时，会把这个对象放入一个队列，然后让finalize守护线程低优先级执行这个队列中对象的finalize方法，如果在finalize方法中这个对象能成功搭上引用链就不会死亡（只有一次机会，如果该类没有重写finalize方法则直接死亡不会加入队列）"}],"id":"17fd9a3db3c3","title":"判断一个对象真正的死亡要经历2个阶段"}],"id":"ebe871a7f7cb","title":"真正的死亡"}],"collapsed":true,"id":"7e8bae393f89","title":"判断对象是否死亡"},{"parent":"d6981a1574d4","children":[{"parent":"27e59ae24ca5","children":[{"parent":"e54ddc4bd384","children":[],"id":"37037effade4","title":"minor GC 回收年轻代"},{"parent":"e54ddc4bd384","children":[],"id":"bcce0252336e","title":"major GC 回收老年代"},{"parent":"e54ddc4bd384","children":[],"id":"b0353799eedb","title":"mixed GC 混合回收年轻代，老年代"},{"parent":"e54ddc4bd384","children":[],"id":"5d0029f53833","title":"full GC 回收整个堆+元空间"}],"id":"e54ddc4bd384","title":"垃圾回收分类"},{"parent":"27e59ae24ca5","children":[{"parent":"76414dc241af","children":[],"id":"2395841a9079","title":"先遍历引用链标记存活的对象，再遍历堆清除没被标记的对象（不是真正清除而是更新空闲列表，下次使用可以覆盖）"}],"id":"76414dc241af","title":"标记-清除算法"},{"parent":"27e59ae24ca5","children":[{"parent":"e836d5920f74","children":[],"id":"98c5c943a40c","title":"使用两块空间（survive from/to）,每次将未空闲的空间上存活的对象移动到另一块空闲的空间上"}],"id":"e836d5920f74","title":"复制算法"},{"parent":"27e59ae24ca5","children":[{"parent":"4a00cd0bb6d4","children":[],"id":"23e421ffb67b","title":"先遍历引用链标记存活对象，再遍历堆时将存活对象整理好"}],"id":"4a00cd0bb6d4","title":"标记-整理算法"},{"parent":"27e59ae24ca5","children":[{"parent":"202133b8088f","children":[],"id":"c8918f6d882c","title":"将用户线程与垃圾回收线程并发（交替）执行"}],"id":"202133b8088f","title":"增量收集算法"},{"parent":"27e59ae24ca5","children":[{"parent":"a737d4b5ed0c","children":[],"id":"07073e8e5dd4","title":"新生代存活对象可能不持久可以使用复制算法（快）"},{"parent":"a737d4b5ed0c","children":[],"id":"410022475eca","title":"老年代存活对象久可以使用标记清除/整理"}],"id":"a737d4b5ed0c","title":"分代收集算法"},{"parent":"27e59ae24ca5","children":[{"parent":"5db58e9fe445","children":[],"id":"2c7e07674efa","title":"将堆内存划分为规格相同的多个区，每次在能够接收的时间回收多个区"}],"id":"5db58e9fe445","title":"分区收集算法"}],"collapsed":true,"id":"27e59ae24ca5","title":"垃圾回收算法"},{"parent":"d6981a1574d4","children":[{"parent":"bb07cd55564e","children":[{"parent":"f0172f3a8902","children":[],"id":"c08adf9ce964","title":"必须STW，保持一致性快照"},{"parent":"f0172f3a8902","children":[],"id":"5abb033b9bf4","title":"遍历引用链耗时（要去方法区中寻找引用的对象），使用OopMap快速找到引用对象（类加载时把该对象的引用类型计算出来，避免扫描方法区）"}],"id":"f0172f3a8902","title":"枚举根节点"},{"parent":"bb07cd55564e","children":[{"parent":"9467bf1b0686","children":[{"parent":"a4bb3c73d9fb","children":[],"id":"280c83e5f060","title":"程序停留在安全点才进行垃圾回收"},{"parent":"a4bb3c73d9fb","children":[],"id":"ccda2d8c686f","title":"OopMap只记录在安全点上的信息（在其他地方也记录开销会很大 ）"},{"parent":"a4bb3c73d9fb","children":[],"id":"e25cf4ee5b54","title":"安全点的位置：指令序列复用（方法调用，循环，异常跳转等 ）"},{"parent":"a4bb3c73d9fb","children":[{"parent":"65fad1842acb","children":[{"parent":"a04a0b558b0d","children":[],"id":"e92b0f19de08","title":"发生垃圾回收时将所有线程中断，如果有线程没在安全点上就恢复它，让他进入最近的安全点"}],"id":"a04a0b558b0d","title":"抢占式中断"},{"parent":"65fad1842acb","children":[{"parent":"58c4bdd353e7","children":[],"id":"72d43a7f8575","title":"设置标志位 ，线程运行时不断轮询标志位，一旦发现标志位为真，说明要发生垃圾回收，去到最近安全点主动挂起"}],"id":"58c4bdd353e7","title":"主动式中断"}],"id":"65fad1842acb","title":"中断方式（如何让用户线程跑到最近的安全点停下来）"}],"id":"a4bb3c73d9fb","title":"安全点"},{"parent":"9467bf1b0686","children":[{"parent":"7529fa01b75b","children":[],"id":"f08a5d4723a9","title":"扩展的安全点，这段代码中未改变对象引用关系（用来处理阻塞状态的线程）"}],"id":"7529fa01b75b","title":"安全区域"}],"id":"9467bf1b0686","title":"安全点与安全区域"},{"parent":"bb07cd55564e","children":[{"parent":"0aadd29ce127","children":[],"id":"f919f4fee0c3","title":"用来处理分代收集的跨代引用问题"},{"parent":"0aadd29ce127","children":[{"parent":"9dd19b711c98","children":[],"id":"b0be3cd09c9c","title":"字长精度"},{"parent":"9dd19b711c98","children":[],"id":"ac058d51d45e","title":"对象精度"},{"parent":"9dd19b711c98","children":[],"id":"eb0cbdc6118a","title":"卡精度"}],"id":"9dd19b711c98","title":"记忆集是抽象的，只需要判断某块非收集区是否指向收集区的指针"},{"parent":"0aadd29ce127","children":[{"parent":"156de8b50afb","children":[],"id":"fc8d158c8ebe","title":"卡表可以用一个数组实现，数组中每个元素对应一块内存（卡页），如果某个卡页中对象存在跨域引用就把这个卡页对应的卡表元素设置为1（表示变脏），将这些脏卡页中存在跨代指针的对象一起加入GC Roots中扫描"}],"id":"156de8b50afb","title":"卡表是实现记忆集卡精度的一种方式"}],"id":"0aadd29ce127","title":"记忆集与卡表"},{"parent":"bb07cd55564e","children":[{"parent":"d7e61550bca3","children":[],"id":"c709241b13e8","title":"卡表变脏在赋值那一刻使用写屏障来维护卡表状态"},{"parent":"d7e61550bca3","children":[],"id":"5ddc1b3aa090","title":"赋值前：写前屏障；赋值后：写后屏障"},{"parent":"d7e61550bca3","children":[],"id":"9c414c5de766","title":"可能产生伪共享问题，先检查卡表标记，只有卡表未被标记才标记为变脏"}],"id":"d7e61550bca3","title":"写屏障"},{"parent":"bb07cd55564e","children":[{"parent":"19f5b553a5b1","children":[],"id":"cff832b674a6","title":"用户线程与GC线程交替执行产生的问题与一系列解决方案"},{"parent":"19f5b553a5b1","children":[{"parent":"1917c926642c","children":[{"parent":"f4d16bddbab5","children":[],"id":"6336ac15552d","title":"白色：未扫描"},{"parent":"f4d16bddbab5","children":[],"id":"2395c6500665","title":"黑色：扫描了自己并且还扫描了所有引用"},{"parent":"f4d16bddbab5","children":[],"id":"6a2f1fbf3dee","title":"灰色：扫描了自己但至少有一个引用还未扫描"}],"id":"f4d16bddbab5","title":"颜色"},{"parent":"1917c926642c","children":[{"parent":"594624178954","children":[],"id":"ba68eeced676","title":"浮动垃圾：将本来变为垃圾的对象标记为黑色，下次GC去回收"},{"parent":"594624178954","children":[],"id":"e5373ff4700a","title":"对象消失：扫描到灰色对象时，断开它与白色对象的引用，添加了黑色对象到白色对象的引用，导致将这个白色对象标记为垃圾"}],"id":"594624178954","title":"可能产生的问题"},{"parent":"1917c926642c","children":[{"parent":"82eb62b8e725","children":[],"id":"fcd9dd9b7e1f","title":"1. 插入一条或多条从黑色对象到白色对象的引用"},{"parent":"82eb62b8e725","children":[],"id":"b509b23995f4","title":"2. 删除全部从灰色对象到白色对象的引用"}],"id":"82eb62b8e725","title":"对象消失发生的条件"},{"parent":"1917c926642c","children":[{"parent":"d55cbe4274fc","children":[],"id":"2f6e44d729ba","title":"只要打破任一满足条件就不会发生错删对象"},{"parent":"d55cbe4274fc","children":[{"parent":"32b39b7f5b6e","children":[],"id":"0e60add6476d","title":"黑色对象一旦插入到白色对象的新引用，就把它记录下来，扫描完后以记录的对象为根节点再扫描一遍（黑色插入引用后变为灰色对象）"},{"parent":"32b39b7f5b6e","children":[],"id":"a725c8fea590","title":"增量更新+写后屏障（记录新引用）"}],"id":"32b39b7f5b6e","title":"增量更新（破坏第一个条件）"},{"parent":"d55cbe4274fc","children":[{"parent":"ad8253cc121c","children":[],"id":"eb864d99ade4","title":"灰色对象一旦删除到白色对象的引用时，就把它指向删除白色对象的引用都记录下来，扫描完后以记录的白色对象变为灰色对象再进行扫描（保持原始的快照，也就是不删除这个引用所以还可能产生浮动垃圾）"},{"parent":"ad8253cc121c","children":[],"id":"f17749615e0e","title":"使用TAMS指针记录新增加引用，隐式可达，重扫时直接变黑色"},{"parent":"ad8253cc121c","children":[],"id":"c5288d8ff2e5","title":"原始快照+写前屏障（记录旧引用）"}],"id":"ad8253cc121c","title":"原始快照（破坏第二个条件）"}],"id":"d55cbe4274fc","title":"对象消失解决方案"}],"id":"1917c926642c","title":"三色标记"}],"collapsed":true,"id":"19f5b553a5b1","title":"并发可达性分析"}],"collapsed":true,"id":"bb07cd55564e","title":"垃圾回收算法细节"},{"parent":"d6981a1574d4","children":[{"parent":"2157b2602f17","image":{"w":60,"h":31,"url":"http://cdn.processon.com/614dcb22e0b34d7b343265c0?e=1632491826&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:u10qPbvll1AAVCaIQBCak4lJff4="},"children":[{"parent":"56721051da20","children":[{"parent":"187a2d5e3198","children":[{"parent":"3e65d3da8778","children":[],"id":"3d6b72a826b3","title":"采用复制算法，串行回收年轻代"}],"id":"3e65d3da8778","title":"serial GC&nbsp;"},{"parent":"187a2d5e3198","children":[{"parent":"51219efcaa01","children":[],"id":"739f8a503c17","title":"标记整理算法，串行回收老年代"}],"id":"51219efcaa01","title":"Serial Old GC&nbsp;"}],"collapsed":true,"id":"187a2d5e3198","title":"串行垃圾收集器"},{"parent":"56721051da20","children":[{"parent":"14f269c1278d","children":[{"parent":"961f1491f2c6","children":[],"id":"daf0ed6ba8bb","title":"复制算法，并行回收年轻代"},{"parent":"961f1491f2c6","children":[],"id":"edf53c4dc1f9","title":"老年代搭配<font color=\"#0d0b22\">Serial Old&nbsp;</font>"}],"id":"961f1491f2c6","title":"ParNew GC&nbsp;"},{"parent":"14f269c1278d","children":[{"parent":"dc1f3f7198a0","children":[{"parent":"3e767aa26667","children":[],"id":"0e4bc46dfe32","title":"复制算法 并行回收年轻代"}],"id":"3e767aa26667","title":"Parallel Scavenge GC"},{"parent":"dc1f3f7198a0","children":[{"parent":"3afeb55bf69d","children":[],"id":"d49bfb2df484","title":"标记整理算法，并行回收老年代"}],"id":"3afeb55bf69d","title":"Parallel Old GC&nbsp;"},{"parent":"dc1f3f7198a0","children":[{"parent":"0c70f00ed11b","customWidth":265,"children":[],"id":"ab29f22daf56","title":"最大停顿时间&nbsp; -XX:MaxGCPauseMillis"},{"parent":"0c70f00ed11b","children":[],"id":"c184fc608639","title":"GC占比&nbsp;-XX:GCTimeRatio"}],"id":"0c70f00ed11b","title":"自适应参数<font color=\"#e96900\">-XX:+UseAdaptiveSizePolicy</font>"}],"id":"dc1f3f7198a0","title":"吞吐量优先级垃圾收集器"}],"collapsed":true,"id":"14f269c1278d","title":"并行垃圾收集器"},{"parent":"56721051da20","children":[{"parent":"758bc8c10ce4","children":[{"parent":"8f4734944ed9","children":[],"id":"d25765eab5bb","title":"标记清除，并发回收老年代"},{"parent":"8f4734944ed9","children":[{"parent":"0040ce4522a6","children":[],"id":"3b645a9f8a8f","title":"1. 初始标记：枚举GC Roots (STW)"},{"parent":"0040ce4522a6","children":[],"id":"8e9f4b8891d0","title":"2. 并发标记：遍历引用链，GC线程与用户线程并发执行"},{"parent":"0040ce4522a6","children":[],"id":"b95db62e4c98","title":"3. 重新标记：使用增量更新+写后屏障），重新扫描加入记录的黑色对象，修正并发标记的结果（STW）"},{"parent":"0040ce4522a6","children":[],"id":"d7c15f5c1e21","title":"4. 并发清理：清理死亡对象，GC用户线程并发执行（不会挪动对象位置，所以可以并发）"}],"id":"0040ce4522a6","title":"回收步骤"},{"parent":"8f4734944ed9","children":[{"parent":"cdd92911d9986d85","children":[],"id":"16b4768b5246304d","title":"GC、用户线程并发执行，降低吞吐量，提高响应时间"},{"parent":"cdd92911d9986d85","children":[],"id":"971df9d07e3bc5e7","title":"老年代可以并发回收，但是年轻代只能使用串行，内存碎片太多老年代还要使用串行整理内存"},{"parent":"cdd92911d9986d85","children":[],"id":"05aaf569385f5355","title":"由于并发执行并没使用标记压缩算法，当内存碎片太多时，需要使用串行GC进行整理"}],"id":"cdd92911d9986d85","title":"特点"}],"id":"8f4734944ed9","title":"CMS（Concurrent Mark Sweep）"},{"parent":"758bc8c10ce4","children":[{"parent":"cdb704250dc8","children":[],"id":"53cfdb87ba68","title":"将堆内存分为多个相同的区，每次回收价值高的多个区"},{"parent":"cdb704250dc8","children":[],"id":"6ee7570d8495","title":"整体：标记-整理，局部：复制"},{"parent":"cdb704250dc8","children":[{"parent":"02f76725ceb5","children":[],"id":"c377097f206b","title":"1. 初始标记：枚举GC Roots (STW)"},{"parent":"02f76725ceb5","children":[],"id":"1c94951f29b0","title":"2. 并发标记：遍历引用链，GC线程与用户线程并发执行"},{"parent":"02f76725ceb5","children":[],"id":"805819be6cae","title":"3. 最终标记：使用原始快照+写前屏障，修正并发标记的结果 （STW）"},{"parent":"02f76725ceb5","children":[],"id":"0c675b510a07","title":"4. 筛选回收：更新区域的价值，放在优先级队列中排序，根据用户指定的停顿时间制定回收计划，将存活对象复制到空区域 （STW）"}],"id":"02f76725ceb5","title":"回收步骤"},{"parent":"cdb704250dc8","children":[{"parent":"a3b3c674d7b89324","children":[],"id":"47e13183e9580ba1","title":"整体标记整理，局部复制 不会产生内存碎片；每次回收垃圾价值最高的区"},{"parent":"a3b3c674d7b89324","children":[],"id":"e403c07498eeb9b7","title":"分区 跨代引用多，维护记忆集（卡表）内存开销大；"},{"parent":"a3b3c674d7b89324","children":[],"id":"e2314fe3e918aefd","title":"适合多核 大内存 低延迟 服务端"}],"id":"a3b3c674d7b89324","title":"特点"}],"id":"cdb704250dc8","title":"G1"}],"collapsed":false,"id":"758bc8c10ce4","title":"并发垃圾收集器"}],"collapsed":false,"id":"56721051da20","title":"经典垃圾收集器"},{"parent":"2157b2602f17","children":[{"parent":"9b6051270b2d","children":[{"parent":"c474d5a69044","children":[],"id":"8e85b632991f","title":"基于region分区的堆内存布局，不分代，回收最大价值区域，使用转发指针，读写屏障，标记整理等技术并发执行"},{"parent":"c474d5a69044","children":[{"parent":"93bd6d027068","children":[],"id":"7291798eeb6d","title":"回收时不分代"},{"parent":"93bd6d027068","children":[],"id":"2d9c1cb90807","title":"回收阶段使用转发指针，读写屏障并发执行"},{"parent":"93bd6d027068","children":[],"id":"8340a984c072","title":"采用连接矩阵记录跨代指针，减少使用记忆集的开销和伪共享问题的概率"}],"id":"93bd6d027068","title":"与G1的区别"},{"parent":"c474d5a69044","image":{"w":79,"h":40,"url":"http://cdn.processon.com/614dcb0a0791290c0c420bb9?e=1632491803&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:2dgS2whltyllsRxw0p6hCCabR44="},"children":[{"parent":"771a1ec37f1d","children":[],"id":"703de5ba19b8","title":"初始标记：STW 枚举GC Roots"},{"parent":"771a1ec37f1d","children":[],"id":"608fb9f302ad","title":"并发标记：遍历引用链"},{"parent":"771a1ec37f1d","children":[],"id":"c8638fb0dd58","title":"最终标记：STW 原始快照+写前屏障 修正标记"},{"parent":"771a1ec37f1d","children":[{"parent":"8341e4c0af90","children":[{"parent":"e54a8e1f8d8b","children":[],"id":"23b48e23ac75","title":"GC线程会移动对象，地址会变，用户线程可能会使用旧地址"},{"parent":"e54a8e1f8d8b","children":[],"id":"6449214434ff","title":"转发指针：访问旧地址时转发指针指向新地址"},{"parent":"e54a8e1f8d8b","children":[],"id":"2265b1003fdc","title":"使用CAS保证用户访问旧地址前，旧地址已经有转发指针指向新地址"}],"id":"e54a8e1f8d8b","title":"用户线程与GC线程并发回收的问题"}],"id":"8341e4c0af90","title":"并发回收：将回收集中的存活对象移动到未被使用的区域中"},{"parent":"771a1ec37f1d","children":[{"parent":"62943101aec9","children":[],"id":"4c0d9014bf5f","title":"初始引用更新：STW 确保所有GC完成分配给它们的移动任务"},{"parent":"62943101aec9","children":[],"id":"76bfb4b58ae5","title":"并发引用更新: 根据物理地址顺序将旧引用改为新引用"},{"parent":"62943101aec9","children":[],"id":"1cc555f635f2","title":"最终引用更新： STW 修正GC Roots的引用"}],"id":"62943101aec9","title":"引用更新：将旧地址更新为新地址"},{"parent":"771a1ec37f1d","children":[],"id":"4cd7356680cf","title":"并发清理：并发清理回收集区域"}],"id":"771a1ec37f1d","title":"回收步骤"}],"id":"c474d5a69044","title":"Shenandoah"},{"parent":"9b6051270b2d","children":[{"parent":"6272914bdaae","children":[],"id":"584e3f04e535","title":"基于region分区的堆内存布局，不分代，使用读屏障，染色指针，内存多重映射，标记整理等技术实现并发执行"}],"id":"6272914bdaae","title":"ZGC"}],"collapsed":true,"id":"9b6051270b2d","title":"低延迟垃圾收集器"}],"collapsed":true,"id":"2157b2602f17","title":"垃圾收集器"},{"parent":"d6981a1574d4","children":[{"parent":"3779df331a05","children":[{"parent":"004301f6f1e2","children":[{"parent":"9f3df3987f8a","children":[],"id":"9a401277917f","title":"没有任何地方引用常量池的常量"}],"id":"9f3df3987f8a","title":"常量"},{"parent":"004301f6f1e2","children":[{"parent":"fe531c15669e","children":[],"id":"ec1672b2872d","title":"该类没有实例对象"},{"parent":"fe531c15669e","children":[],"id":"e95196daab66","title":"加载该类的类加载器被回收"},{"parent":"fe531c15669e","children":[],"id":"c90c2ed4d0fb","title":"该类对应Class对象未被使用"}],"id":"fe531c15669e","title":"类"}],"id":"004301f6f1e2","title":"回收方法区"},{"parent":"3779df331a05","image":{"w":83,"h":67,"url":"http://cdn.processon.com/614dcc6f5653bb2ea6e1968f?e=1632492159&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:RTjCzvJ70w3_MILN7M4vVwVA5Gk="},"children":[{"parent":"3da3e939bf63","children":[],"id":"31b7c359cca3","title":"对象优先在Eden区分配"},{"parent":"3da3e939bf63","children":[],"id":"88f19cacc9ea","title":"老年代最大连续可用空间大于新生代所有对象或以前上升到老年代的平均大小就进行minor gc否则进行full gc"},{"parent":"3da3e939bf63","children":[{"parent":"126e84ec5101528c","children":[],"id":"43e453e548f2","title":"大对象直接分配到老年代"},{"parent":"126e84ec5101528c","children":[],"id":"4457b2714e87","title":"经历一定minor gc的对象进入老年代"},{"parent":"126e84ec5101528c","children":[],"id":"ac3df4e6bf8ddbf6","title":"经历minor gc后 幸存区超过一半 放入老年代"}],"id":"126e84ec5101528c","title":"进入老年代的方式"}],"id":"3da3e939bf63","title":"回收堆内存"}],"collapsed":true,"id":"3779df331a05","title":"内存分配回收策略"}],"id":"d6981a1574d4","title":"垃圾回收篇"},{"parent":"root","lineStyle":{"randomLineColor":"#7549C5"},"children":[{"parent":"e495d40a5079","children":[{"parent":"6eac60c3aa33","children":[{"parent":"9ac8fe28aa79","children":[],"id":"570ed7852c33","title":"jps 查看Java进程"},{"parent":"9ac8fe28aa79","children":[],"id":"a8eb67294dad","title":"jstat 查看某Java进程各种信息占用情况"},{"parent":"9ac8fe28aa79","children":[],"id":"22d9a3cd52f7","title":"jinfo 查看Java进程参数信息"},{"parent":"9ac8fe28aa79","children":[],"id":"4760ed2fe25b","title":"jmap 导出dump文件"},{"parent":"9ac8fe28aa79","children":[],"id":"9cdf8095bedc","title":"jhat 分析dump文件（会占CPU一般不用）"},{"parent":"9ac8fe28aa79","children":[],"id":"2cf221d40dd3","title":"jstack 查看某个Java进程中线程的信息"}],"collapsed":true,"id":"9ac8fe28aa79","title":"命令行"},{"parent":"6eac60c3aa33","children":[{"parent":"b8ab64b815d5","children":[],"id":"090aae3446a5","title":"jvisualvm"},{"parent":"b8ab64b815d5","children":[],"id":"d2ae82b12127","title":"jprofile"}],"collapsed":true,"id":"b8ab64b815d5","title":"GUI"},{"parent":"6eac60c3aa33","children":[{"parent":"d62be4db01a34412","children":[],"id":"dfe8175851a04fad","title":"dashboard 仪表盘 ：线程、JVM、OS等情况"},{"parent":"d62be4db01a34412","children":[],"id":"c96fcc893d9d47ba","title":"sc -d&nbsp; *.XXX 查看匹配的类信息"},{"parent":"d62be4db01a34412","children":[{"parent":"3a71830639455004","children":[],"id":"e9b13641a39ebe5e","title":"jad --source-only java.lang.String 反编译"},{"parent":"3a71830639455004","children":[],"id":"f90cea69671d75a6","title":"jad --source-only java.lang.String equals 反编译方法"}],"id":"3a71830639455004","title":"jad 反编译"},{"parent":"d62be4db01a34412","children":[],"id":"089b5c1923284c3e","title":"stack 调用栈"},{"parent":"d62be4db01a34412","children":[],"id":"1afc30eea723a837","title":"monitor 监听一段时间"},{"parent":"d62be4db01a34412","children":[{"parent":"305334b5ebcea041","children":[],"id":"8b68dd1d72120a20","title":"监听 方法耗时 优化 接口"}],"id":"305334b5ebcea041","title":"trace 全限定类名 方法名"},{"parent":"d62be4db01a34412","children":[{"parent":"d6ccf534f37afc19","children":[],"id":"013b463831ef2cab","title":"-t 时间"},{"parent":"d6ccf534f37afc19","children":[],"id":"47b309f899c9f4e4","title":"-n 最多调用次数"},{"parent":"d6ccf534f37afc19","children":[],"id":"766e72c2d5e63e02","title":"-m 最多class次数"},{"parent":"d6ccf534f37afc19","children":[],"id":"5863d2ac24b790c1","title":"tt -i xxx 查看某次调用"},{"parent":"d6ccf534f37afc19","children":[],"id":"c18ac1adefdb44f1","title":"tt -i xx -p 1 重新调用1次"}],"id":"d6ccf534f37afc19","title":"tt -t -n 4 -m 4 全限定类名 方法名"},{"parent":"d62be4db01a34412","children":[{"parent":"3cd3a3b3ab3c950d","children":[],"id":"7fbc8e3d9e2fa1dd","title":"profiler"}],"id":"3cd3a3b3ab3c950d","title":"火焰图"}],"collapsed":true,"id":"d62be4db01a34412","title":"arthas"}],"collapsed":true,"id":"6eac60c3aa33","title":"监控工具"},{"parent":"e495d40a5079","children":[{"parent":"06d5159e6fab","children":[{"parent":"365b7d0e06e9","children":[],"id":"7aff5a5f1985","title":"-XX：+PrintGCDetails&nbsp;"},{"parent":"365b7d0e06e9","children":[],"id":"a446bad95b89","title":"-XX：+PrintGCTimeStamps"},{"parent":"365b7d0e06e9","children":[],"id":"805916b50e04","title":"-Xloggc: 位置&nbsp; （将GC信息输出到某个位置）"}],"id":"365b7d0e06e9","title":"GC日志参数"},{"parent":"06d5159e6fab","children":[{"parent":"6fbc3ef9efc1","note":"`-Xss100k` 设置栈内存为100k,等同于`-XX:ThreadStackSize`","children":[],"id":"cc6251fd2f2d","title":"栈"},{"parent":"6fbc3ef9efc1","note":"- `-Xms100m` 设置堆内存初始化为100m,等同于`-XX:InitalHeapSize=100m`\n- `-Xmx100m` 设置最大堆内存为100m,等同于`-XX:MaxHeapSize=100m`\n- `-Xmn2g` 设置年轻代最大内存为2g,等同于`-XX:NewSize=2g`+`-XX:MaxNewSize=2g`\n\n- `-XX:+UseAdaptiveSizePolicy` 自动选择各区比例大小(默认开启)\n- `-XX:SurvivorRatio=8` 设置survivor:Eden占比为 1:1:8\n\t- 这个值默认为8,如果`-XX:+UseAdaptiveSizePolicy`是开启的,survivor:eden比例会被自动调成为1:1:6\n- `-XX:NewRatio=2` 设置年轻代:老年代占比为 1:2\n- `-XX:PretenureSizeThreadshold=2014` 设置内存大于此值(byte)的对象作为大对象直接分配到老年代\n- `-XX:MaxTenuringThreshold=15` 对象年龄超过15进入老年代\n- `-XX:+PrintTenuringDistribution` JVM每次MinorGC后打印出当前使用的Survivor中对象的年龄分布\n- `-XX:TargetSurvivorRatio` MinorGC结束后Survivor区域中占用空间的期望比例","children":[],"id":"e2e79b0ba361","title":"堆"},{"parent":"6fbc3ef9efc1","note":"- `-XX:MetaspaceSize` 元空间初始大小\n- `-XX:MaxMetaspaceSize` 元空间最大大小\n- `-XX:+UseCompressedOops` 使用压缩对象指针\n- `-XX:+UseCompressedClassPointers` 使用压缩类执行\n- `-XX:ComporessedClassSpaceSize` 设置ClassMetaspace大小,默认1g","children":[],"id":"c741bdbc8ced","title":"方法区"},{"parent":"6fbc3ef9efc1","note":"`-XX:MaxDiectMemorySize` 设置直接内存大小,未指定则和最大堆内存一致","children":[],"id":"a6262efe91a7","title":"直接内存"}],"id":"6fbc3ef9efc1","title":"运行时内存区常用参数"},{"parent":"06d5159e6fab","note":"- `-XX:+HeapDumpOutOfMemoryError` 发生OOM时生成堆dump文件\n\n- `-XX:+HeapDumpBeforeFullGC` 发生FullGC时生成堆dump文件\n\n\t- OOM前会多次FullGC也就是可能多次生成dump文件\n- `-XX:HeapDumpPath=d:\\`指定生成堆dump文件路径为d:\\ (默认生成的dump文件在项目当前目录下)\n\n- `-XX:OnOutOfMemoryError=/opt/restart.sh`  发生OOM时去执行/opt/restart.sh文件","children":[],"id":"792f863b881e","title":"OOM相关参数"},{"parent":"06d5159e6fab","children":[{"parent":"a06dc59a5630","note":"`-XX:+UseSerialGC` 年轻代,老年代都使用串行收集器","children":[],"id":"9d787a85ed7a","title":"串行"},{"parent":"a06dc59a5630","children":[{"parent":"a95c29deecc6","note":"`-XX:+UseParNewGC` 年轻代使用ParNew收集器","children":[],"id":"9c506c5e194f","title":"ParNew"},{"parent":"a95c29deecc6","note":"- `-XX:+UseParallelGC`  `-XX:+UseParallelOldGC` 使用任意一个参数,新生代,老年代就会使用Parallel收集器\n- `-XX:ParallelGCThreads` 设置年轻代并行收集线程个数 \n\t- 逻辑处理器(CPU)个数 &lt; 8 : 设置与核心数相同\n\t- CPU个数 &gt; 8 : 设置线程数 = 3 + (5 * 核心数) / 8\n- `-XX:+UseAdaptiveSizePolicy` 自适应调节策略\n- `-XX:MaxGCPauseMillis` 设置最大STW时间,单位ms\n\t- Parallel 主打高吞吐量优先,该参数具体值最好由`-XX:+UseAdaptiveSizePolicy`来分配\n- `-XX:GCTimeRatio=N` 垃圾收集时间占比(1/N+1)\n\t- 用于衡量吞吐量,该值设置越大就与设置最大STW时间`-XX:MaxGCPauseMillis` 矛盾,不能同时使用","children":[],"id":"ebfdf081a2d2","title":"Parallel"}],"id":"a95c29deecc6","title":"并行"},{"parent":"a06dc59a5630","children":[{"parent":"e543803a5f7f","note":"- `-XX:+UseConcMarkSweepGC`老年代使用CMS垃圾收集器,新生代使用ParNew收集器\n- `-XX:CMSInitiatingOccupancyFraction`设置老年代使用多少空间时开始垃圾回收\n\t- 如果设置的太高,不够内存分配,不能满足并发执行,就会冻结用户线程启动Serial Old收集器,停顿时间就会变长\n\t- 如果内存增长缓慢可以设置高一些,如果内存增长很快就要设置低一些 默认92%\n- `-XX:+UseCMSCompactAtFullCollection`指定在FULL GC后是否对内存进行压缩整理\n\t- 开启后,通过`-XX:CMSFullGCsBeforeCompaction`设置执行多少次FULL GC后进行内存压缩整理\n- `-XX:ParallelCMSThreads` 设置CMS线程数量","children":[],"id":"66b42fc33a21","title":"CMS"},{"parent":"e543803a5f7f","note":"- `-XX:+UseG1GC` 使用G1收集器\n\n- `-XX:G1HeapRegionSize`设置每个region大小\n\n- `-XX:MaxGCPauseMillis`设置预期停顿时间 (默认200ms,最好不要太小)\n\n- `-XX:ParallelGCThread`设置STW时GC线程数\n\n- `-XX:ConcGCThreads`设置并发标记线程数\n\n- `-XX:InitiatingHeapOccupancyPercent`设置触发老年代GC的堆占用率阈值","children":[],"id":"7cd9e4fa6147","title":"G1"}],"id":"e543803a5f7f","title":"并发"}],"id":"a06dc59a5630","title":"垃圾收集器参数"}],"collapsed":true,"id":"06d5159e6fab","title":"JVM运行时参数"},{"parent":"e495d40a5079","children":[{"parent":"6800503bebea","children":[{"parent":"883811697bf1","children":[],"id":"b59587c25d20","title":"静态集合"},{"parent":"883811697bf1","children":[],"id":"504f695b1c53","title":"饿汉单例"},{"parent":"883811697bf1","children":[],"id":"b43fcd3378e5","title":"非静态内部类有指针指向外部对象"},{"parent":"883811697bf1","children":[],"id":"737378f0b412","title":"变量作用域不合理（局部变量设置为实例变量）"},{"parent":"883811697bf1","children":[],"id":"511d2745a51b","title":"隐式内存泄漏（集合中删除操作要置空元素，否则表面上没影响实际导致内存泄漏）"}],"id":"883811697bf1","title":"对象生命周期变长引发内存泄漏"},{"parent":"6800503bebea","children":[{"parent":"fe1cb77d7fd0","children":[],"id":"f952c3065c38","title":"不关闭IO流，连接等资源"}],"id":"fe1cb77d7fd0","title":"不关闭资源导致内存泄漏"},{"parent":"6800503bebea","children":[{"parent":"0c279ac4aff0","children":[],"id":"8d9773144328","title":"改变对象关键域，哈希值也会发生变化，就在Map中找不到原来位置了，从而导致内存泄漏"}],"id":"0c279ac4aff0","title":"改变对象哈希值引发内存泄漏"},{"parent":"6800503bebea","children":[{"parent":"046140ad86a1","children":[],"id":"febbf9326751","title":"缓存充当Map的K时，不再使用要手动删除；或者使用weakHashMap"}],"id":"046140ad86a1","title":"缓存导致内存泄漏"}],"collapsed":true,"id":"6800503bebea","title":"内存泄漏"},{"parent":"e495d40a5079","children":[{"parent":"70cfcf96263b","children":[],"id":"bbef5cd9064c","title":"编译时间"},{"parent":"70cfcf96263b","children":[{"parent":"1799941437f1","children":[],"id":"ed01f1c06216","title":"-Xveify:none 禁止校验"}],"id":"1799941437f1","title":"类加载时间"},{"parent":"70cfcf96263b","children":[{"parent":"e31c2cdd3ce2","children":[],"id":"d7e5558eb3ba","title":"频繁minor gc 而不full gc可以尝试增大年轻代"},{"parent":"e31c2cdd3ce2","children":[{"parent":"c65e77300340","children":[],"id":"dd6ee1d075a1","title":"可能是程序中调用System.gc()&nbsp;可以使用-XX：DisableExplictGC禁止"},{"parent":"c65e77300340","children":[],"id":"0eb6f9a8b665","title":"还可能是元空间不够，可以尝试增大元空间"}],"id":"c65e77300340","title":"如果Old区稳定，频繁full gc&nbsp;"},{"parent":"e31c2cdd3ce2","children":[],"id":"616e560cc197","title":"根据需求选择不同的垃圾收集器"}],"id":"e31c2cdd3ce2","title":"GC时间"}],"collapsed":true,"id":"70cfcf96263b","title":"调优分析"},{"parent":"e495d40a5079","children":[{"parent":"8094590e77f5a045","children":[{"parent":"ba5016cae484302e","children":[],"id":"95a4eda122f1d915","title":"排查：服务出现卡顿，监控面板，发现有时候Full GC的时间很久，查看使用的收集器是默认的并行高吞吐量"},{"parent":"ba5016cae484302e","children":[],"id":"4cd3bc998a1b105f","title":"猜测：随着堆内存的提升，并行回收STW太久导致造成卡顿，考虑更换并行收集器CMS或G1"},{"parent":"ba5016cae484302e","children":[{"parent":"67d0ec7d0358b265","children":[],"id":"29e1be6095554c51","title":"CMS只是老年代的并发，年轻代依旧是并行，并且会造成内存碎片，整理时还是需要串行"},{"parent":"67d0ec7d0358b265","children":[],"id":"30fd3027510bb123","title":"而且该服务器属于多核大内存（4核8G、8核16G）堆内存可用超过6G，更偏向使用G1"}],"id":"67d0ec7d0358b265","title":"考虑"},{"parent":"ba5016cae484302e","children":[{"parent":"875a281d82f54a0e","children":[],"id":"408a3f60e346d409","title":"使用G1"}],"id":"875a281d82f54a0e","title":"解决"}],"id":"ba5016cae484302e","title":"并行高吞吐量收集器卡顿"},{"parent":"8094590e77f5a045","children":[{"parent":"db0494df59e51ceb","children":[{"parent":"12a0755e2e8affc0","children":[],"id":"2b69d151c9d1cf38","title":"服务出现卡顿，观察监控面板，发现Java&nbsp;服务&nbsp;CPU忽高忽低"},{"parent":"12a0755e2e8affc0","children":[],"id":"8b4ddd241a43659a","title":"猜测GC，观察一段时间GC情况，发现full gc频率稍微高"}],"id":"12a0755e2e8affc0","title":"排查"},{"parent":"db0494df59e51ceb","children":[{"parent":"ef231f57ffeb145e","children":[],"id":"9eafbd94103e8e48","title":"可能有生命周期短的大对象直接进入老年代"},{"parent":"ef231f57ffeb145e","children":[],"id":"b617645a7a9b62f7","title":"minor gc后幸存区对象超过一半进入老年代"}],"id":"ef231f57ffeb145e","title":"猜测"},{"parent":"db0494df59e51ceb","children":[],"id":"33c00964af3c6ec5","title":"观察GC情况，发现每次young&nbsp;gc都会有部分对象进入老年代，猜测可能是幸存区太小，经历minor&nbsp;gc后&nbsp;幸存区超过一半会进入老年代，将幸存区调大"}],"id":"db0494df59e51ceb","title":"幸存区设置太小，对象提前进入老年代"}],"collapsed":true,"id":"8094590e77f5a045","title":"JVM调优案例"},{"parent":"e495d40a5079","children":[{"parent":"e1df9d7508988f35","children":[{"parent":"bf67363dbc35f532","children":[{"parent":"220a0872230f5149","children":[],"id":"b85a16de32f5ac10","title":"B端商品导出功能出现OOM，拿到dump文件 查看 发现字符串为大对象"}],"id":"220a0872230f5149","title":"排查"},{"parent":"bf67363dbc35f532","children":[{"parent":"507a1fa0a336594e","children":[],"id":"e671bdd1ea1f4045","title":"由于导出功能涉及到的数据量很大，猜测可能是并发请求导致"},{"parent":"507a1fa0a336594e","children":[],"id":"da46954b2a9cf759","title":"查看业务代码逻辑后端没有作防重，查看B端发现前端也没做防重，与业务人员沟通发现，导出数据太慢又没响应导致重复点击，从而出现大数据量的导出导致OOM"}],"id":"507a1fa0a336594e","title":"猜测"},{"parent":"bf67363dbc35f532","children":[{"parent":"88fea3cb7aeaabeb","children":[],"id":"b43c39ea1eb19aa8","title":"前端做好防重、后端做好接口级别防重"},{"parent":"88fea3cb7aeaabeb","children":[],"id":"993543912546e632","title":"其他优化方案：多线程查数据、异步导出通知用户 （由于业务优先级问题，后续改进）"}],"id":"88fea3cb7aeaabeb","title":"解决"}],"id":"bf67363dbc35f532","title":"B端导出出现OOM"},{"parent":"e1df9d7508988f35","children":[{"parent":"c8d0486bbd5b3185","children":[],"id":"24b86bd4e5c255a6","title":"单个缓存 数据量太大，高并发进来时，解析/读取数据 量太大 出现OOM，将单个缓存存储的数据进行分片，需要什么数据就去查哪片的数据"}],"id":"c8d0486bbd5b3185","title":"单缓存、高并发出现OOM"},{"parent":"e1df9d7508988f35","children":[],"id":"1c9d1479d075b45c","title":"kafka&nbsp; 异步日志数据量太大，等待被打印 导致OOM"},{"parent":"e1df9d7508988f35","children":[],"id":"079435e07cfb","title":"线程池OOM，未设置阻塞队列上限导致 OOM"}],"collapsed":true,"id":"e1df9d7508988f35","title":"OOM排查案例"},{"parent":"e495d40a5079","children":[{"parent":"dae75e00f19a7f67","children":[{"parent":"c0dd2fd6576a5495","children":[],"id":"8170e04c40caf9ca","title":"导出表格OOM，数据量大，没做防重导致"}],"id":"c0dd2fd6576a5495","title":"堆内存OOM"}],"collapsed":true,"id":"dae75e00f19a7f67","title":"OOM案例"},{"parent":"e495d40a5079","children":[{"parent":"c20a360ab10c1627","children":[{"parent":"2d2259050ef9f541","children":[],"id":"fa440153823255eb","title":"大量线程阻塞导致利用率不高，大量线程等待导致负载高"},{"parent":"2d2259050ef9f541","children":[],"id":"dd182f6613b51a4c","title":"线程频繁上下文切换导致负载高，用户线程没怎么执行（等待资源）利用率低"}],"id":"2d2259050ef9f541","title":"CPU利用率不高但是CPU负载高"}],"collapsed":true,"id":"c20a360ab10c1627","title":"CPU飙升"}],"id":"e495d40a5079","title":"性能调优篇"}],"root":true,"theme":"delicate_caihong","showWatermark":false,"id":"root","title":"JVM<br>","version":550,"structure":"mind_right"}},"meta":{"exportTime":"2024-03-04 21:59:59","member":"","diagramInfo":{"creator":"","created":"2020-11-22 16:04:12","modified":"2024-03-04 21:58:00","title":"JVM","category":"mind_free"},"id":"5fba1b7c1e0853687723e593","type":"ProcessOn Schema File","version":"5.0"}}