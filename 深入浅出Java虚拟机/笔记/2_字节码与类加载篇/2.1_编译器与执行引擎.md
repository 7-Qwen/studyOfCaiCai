[toc]













本篇文章将围绕Java中的编译器，深入浅出的解析前端编译的流程、泛型、条件编译、增强for循环、可变长参数、lambda表达式等语法糖原理



## 编译器与执行引擎

### 编译器

Java中的编译器不止一种，Java编译器可以分为：**前端编译器、即时编译器和提前编译器**

最为常见的就是**前端编译器javac，它能够将Java源代码编译为字节码文件，它能够优化程序员使用起来很方便的语法糖**

**即时编译器是在运行时，将热点代码直接编译为本地机器码，而不需要解释执行，提升性能**

**提前编译器将程序提前编译成本地二进制代码**



### 前端编译过程

- 准备阶段: 初始化插入式注解处理器

- 处理阶段

	- 解析与填充符号表

		1. **词法分析: 将Java源代码的字符流转变为token(标记)流**
			- 字符: 程序编写的最小单位
			- 标记(token) :  编译的最小单位
			- 比如 关键字 static 是一个标记 / 6个字符

		2. **语法分析: 将token流构造成抽象语法树**

		3. **填充符号表: 产生符号信息和符号地址**
			- 符号表是一组符号信息和符号地址构成的数据结构
			- 比如: 目标代码生成阶段，对符号名分配地址时，要查看符号表上该符号名对应的符号地址

	- 插入式注解处理器的注解处理

		4. **注解处理器处理特殊注解: 在编译器允许注解处理器对源代码中特殊注解作处理，可以读写抽象语法树中任意元素，如果发生了写操作，就要重新解析填充符号表**
			- 比如: Lombok通过特殊注解，生成get/set/构造器等方法

	- 语义分析与字节码生成

		5. **标注检查: 对语义静态信息的检查以及常量折叠优化**

			```java
			int i = 1;
			char c1 = 'a';
			int i2 = 1 + 2;//编译成 int i2 = 3 常量折叠优化
			char c2 = i + c1; //编译错误 标注检查 检查语法静态信息 
			```

			![image-20210524202623150](虚拟机字节码执行引擎.assets/image-20210524202623150.png)

		6. **数据及控制流分析: 对程序运行时动态检查**

			- 比如方法中流程控制产生的各条路是否有合适的返回值

		7. **解语法糖: 将(方便程序员使用的简洁代码)语法糖转换为原始结构**

		8. **字节码生成: 生成`<init>,<clinit>`方法,并根据上述信息生成字节码文件**

> 总结流程图

![image-20210524205803664](虚拟机字节码执行引擎.assets/image-20210524205803664.png)



> 源码分析

![image-20210524222754508](虚拟机字节码执行引擎.assets/image-20210524222754508.png)

代码位置在JavaCompiler的compile方法中

![image-20210524221445424](虚拟机字节码执行引擎.assets/image-20210524221445424.png)





### Java中的语法糖

#### 泛型

**将操作的数据类型指定为方法签名中一种特殊参数，作用在方法、类、接口上时称为泛型方法、泛型类、泛型接口**

Java中的泛型是**类型擦除式泛型**，泛型只在源代码中存在，**在编译期擦除泛型，并在相应的地方加上强制转换代码**

> 与具现化式泛型(不会擦除，运行时也存在泛型)对比

- 优点: 只需要改动编译器，Java虚拟机和字节码指令不需要改变

	- 因为泛型是JDK5加入的，为了满足对以前版本代码的兼容采用类型擦除式泛型

- 缺点: 性能较低，使用没那么方便

	- 为提供基本类型的泛型，只能自动拆装箱，在相应的地方还会加速强制转换代码，所以性能较低

	- 运行期间无法获取到泛型类型信息

		- 比如书写泛型的List转数组类型时，需要在方法的参数中指定泛型类型

			```java
			public static <T> T[] listToArray(List<T> list,Class<T> componentType){
			        T[] instance = (T[]) Array.newInstance(componentType, list.size());
			        return instance;
			}
			```

			

#### 增强for循环与可变长参数

![image-20210524213429033](虚拟机字节码执行引擎.assets/image-20210524213429033.png)

增强for循环 -> 迭代器

可变长参数 -> 数组装载参数

泛型擦除后会在某些位置插入强制转换代码



#### 自动拆装箱

> 自动装箱、拆箱的错误用法

```java
		Integer a = 1;
        Integer b = 2;
        Integer c = 3;
        Integer d = 3;
        Integer e = 321;
        Integer f = 321;
        Long g = 3L;
		//true
        System.out.println(c == d);//范围小，在缓冲池中
		//false
        System.out.println(e == f);//范围大，不在缓冲池中，比较地址因此为false
		//true
        System.out.println(c == (a + b));
		//true
        System.out.println(c.equals(a + b));
		//false
        System.out.println(g == (b + a));
		//true
        System.out.println(g.equals(a + b));
```

- 注意: 

	1. 包装类重写的equals方法中不会自动转换类型

		![image-20210524213853321](虚拟机字节码执行引擎.assets/image-20210524213853321.png)

	2. 包装类的 == 就是去比较引用地址，不会自动拆箱





#### 条件编译

布尔类型 + if语句 : **根据布尔值类型的真假，编译器会把分支中不成立的代码块消除（解语法糖）**

![image-20210524214427206](虚拟机字节码执行引擎.assets/image-20210524214427206.png)





#### Lambda原理

> 编写函数式接口

```java
@FunctionalInterface
interface LambdaTest {
    void lambda();
}
```



> 编写测试类

```java
public class Lambda {
    private int i = 10;

    public static void main(String[] args) {
        test(() -> System.out.println("匿名内部类实现函数式接口"));
    }

    public static void test(LambdaTest lambdaTest) {
        lambdaTest.lambda();
    }
}
```



> 使用插件查看字节码文件

![image-20210524230643123](虚拟机字节码执行引擎.assets/image-20210524230643123.png)

生成了一个私有静态的方法,这个方法中很明显就是lambda中的代码

**在使用lambda表达式的类中隐式生成一个静态私有的方法，这个方法代码块就是lambda表达式中写的代码**

![image-20210524232010510](虚拟机字节码执行引擎.assets/image-20210524232010510.png)

执行class文件时带上参数`java -Djdk.internal.lambda.dumpProxyClasses 包名.类名`即可显示出这个匿名内部类

![image-20210527083659256](编译器与执行引擎.assets/image-20210527083659256.png)

**使用`invokedynamic`生成了一个实现函数式接口的匿名内部类对象，在重写函数式接口的方法实现中调用使用lambda表达式类中隐式生成的静态私有方法**







### 总结

本篇文章以Java中编译器的分类为开篇，深入浅出的解析前端编译的流程，Java中泛型、增强for循环、可变长参数、自动拆装箱、条件编译以及Lambda等语法糖的原理

**前端编译先将字符流转换为token流，再将token流转换为抽象语法树，填充符号表的符号信息、符号地址，然后注解处理器处理特殊注解（比如Lombok生成get、set方法），对语法树发生写改动则要重新解析、填充符号，接着检查语义静态信息以及常量折叠，对运行时程序进行动态检查，再解语法糖，生成init实例方法、clinit静态方法，最后生成字节码文件**

**Java中为了兼容之前的版本使用类型擦除式的泛型，在编译期间擦除泛型并在相应位置加上强制转换，想为基本类型使用泛型只能搭配自动拆装箱一起使用，性能有损耗且在运行时无法获取泛型类型**

**增加for循环则是使用迭代器实现，并在适当位置插入强制转换；可变长参数则是创建数组进行装载参数**

**自动拆装箱提供基本类型与包装类的转换，但包装类尽量不使用==，这是去比较引用地址，同类型比较使用equals**

**条件编译会在if-else语句中根据布尔类型将不成立的分支代码块消除**

**lambda原理则是通过`invokeDynamic`指令动态生成实现函数式接口的匿名对象，匿名对象重写函数时接口方法中调用使用lambda表达式类中隐式生成的静态私有的方法（该方法就是lambda表达式中的代码内容）**















 本篇文章围绕执行引擎，**深入浅出的解析执行引擎中解释器与编译器的解释执行和编译执行、执行引擎的执行方式、逃逸分析带来的栈上分配、锁消除、标量替换等优化、最后说明即时编译器编译对热点代码的探测以及虚拟机使用栈指令集的优缺点**



### 执行引擎

> hotspot执行引擎结构图

执行引擎分为解释器、JIT即时编译器以及垃圾收集器

**执行引擎通过解释器/即时编译器将字节码指令解释/编译为对应OS上的的机器指令**

![image-20210430191033833](虚拟机字节码执行引擎.assets/image-20210430191033833.png)

本篇文章主要围绕解释器与即时编译器，垃圾收集器将在后续文章解析



### 解释执行与编译执行

Java虚拟机执行引擎在执行Java代码时，会有两种选择:==解释执行和编译执行==

解释执行：通过**字节码解释器把字节码解析为机器语言**执行

编译执行：通过**即时编译器产生本地代码**执行

Class文件中的代码到底是解释执行还是编译执行只有Java虚拟机自己才能判断准确

> 编译过程

![image-20201113160400365](虚拟机字节码执行引擎.assets/image-20201113160400365.png)

编译流程在前一篇文章[]()已经说明，在本篇文章中不再概述

经典编译原理: **1.对源码进行词法，语法分析处理  2.把源码转换为抽象语法树**

**javac编译器完成了对源码进行词法，语法分析处理为抽象语法树，再遍历抽象语法树生成线性字节码指令流的过程**

剩下的指令流有两种方式执行

1. 由虚拟机内部的字节码解释器去将字节码指令进行逐行解释  （解释执行）

2. 或优化器（即时编译器）优化代码最后生成目标代码  （编译执行）

> 执行引擎流程图

![image-20210430150736000](虚拟机字节码执行引擎.assets/image-20210430150736000.png)





### 解释器与编译器

> 解释器

**作用: 对字节码指令逐行解释**

优点: 程序启动，解释器立即解释执行

缺点: 低效



> 即时编译器 (just in time compiler)

Java中的"编译期"不确定

- 可能说的是执行javac指令时的前端编译器 (.java->.class)
- 也可能是后端编译器JIT (字节指令->机器指令)
- 还可能是AOT编译器(静态提前编译器)  (.java->机器指令)

**作用: 将方法编译成机器码缓存到方法区，每次调用该方法执行编译后的机器码**

优点: 即时编译器把代码编译成本地机器码，执行效率高，高效

缺点: 程序启动时，需要先编译再执行



### 执行引擎执行方式

执行引擎执行方式大致分为3种

`-Xint`: 完全采用解释器执行

`-Xcomp`: 优先采用即时编译器执行，解释器是后备选择

`-Xmixed`: 采用解释器 + 即时编译器

![image-20210430194043245](虚拟机字节码执行引擎.assets/image-20210430194043245.png)

hotspot中有两种JIT即时编译器

Client模式下的**C1编译器：简单优化，耗时短**（C1优化策略：方法内联，去虚拟化，冗余消除）

Server模式下的**C2编译器：深度优化，耗时长** （C2主要是逃逸分析的优化：标量替换，锁消除，栈上分配）

**分层编译策略：程序解释执行（不开启逃逸分析）可以触发C1编译，开启逃逸分析可以触发C2编译**

**解释器，C1，C2编译器同时工作，热点代码可能被编译多次**

解释器在程序刚刚开始的时候解释执行，不需要承担监控的开销

C1有着更快的编译速度，能为C2编译优化争取更多时间

C2用高复杂度算法，编译优化程度很高的代码





### 逃逸分析带来的优化

**当对象作用域只在某个方法时，不会被外界调用到**，那么这个对象就不会发生逃逸

开启逃逸分析后，会分析对象是否发生逃逸，**当不能发生逃逸时会进行栈上分配、锁消除、标量替换等优化**



#### 栈上分配内存

```java
//-Xms1G -Xmx1G -XX:+PrintGCDetails 
public class StackMemory {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        for (int i = 0; i < 10000000; i++) {
            memory();
        }

        System.out.println("花费时间:"+(System.currentTimeMillis()-start)+"ms");

        try {
            TimeUnit.SECONDS.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static void memory(){
        StackMemory memory = new StackMemory();
    }
}
```

-XX:-DoEscapeAnalysis 花费时间:63ms  (未开启逃逸分析)

-XX:+DoEscapeAnalysis 花费时间:4ms (开启逃逸分析)

**默认开启逃逸分析**



#### 锁消除

同步加锁会带来开销

锁消除：当加锁对象只作用某个方法时，JIT编译器借助逃逸分析**判断使用的锁对象是不是只能被一个线程访问**，如果是这种情况下就不需要同步，可以取消这部分代码的同步，提高并发性能



#### 标量替换

标量: 无法再分解的数据 (基本数据类型)

聚合量: 还可以再分解的数据 (对象)

**标量替换: JIT借助逃逸分析，该对象不发生逃逸，只作用于某个方法会把该对象(聚合量)拆成若干个成员变量(标量)来代替**

**默认开启标量替换**

```java
public class ScalarSubstitution {
    static class Man{
        int age;
        int id;

        public Man() {
        }
    }

    public static void createInstance(){
        Man man = new Man();
        man.id = 123;
        man.age = 321;
    }
    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        for (int i = 0; i < 10000000; i++) {
            createInstance();
        }

        System.out.println("花费时间:"+(System.currentTimeMillis()-start)+"ms");

        try {
            TimeUnit.SECONDS.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
//-Xmx200m -Xms200m -XX:+PrintGCDetails 
//-XX:+DoEscapeAnalysis 设置开启逃逸分析
//-XX:-EliminateAllocations 设置不开启标量替换 
//开启逃逸分析 + 关闭标量替换 : 花费时间:93ms
//开启逃逸分析 + 开启标量替换  : 花费时间:6ms
```





### 热点代码与热点探测

JIT编译器并不是编译所有的字节码，JIT编译器只编译热点代码

**热点代码: 被多次调用的方法 或 方法中多次循环的循环体**

**栈上替换(OSR): JIT将方法中的热点代码编译为本地机器指令（被多次执行的循环体）**

**编译对象都是方法，如果是栈上替换则"入口"在方法的循环体开始那里**

**热点探测功能**决定了被调用多少次的方法能成为热点代码

hotspot采用**基于计数器的热点探测**

- **方法调用计数器 : 统计方法调用次数**
- **回边计数器 : 统计循环体执行循环次数**

方法调用时先判断是否有执行编译后的机器码，有则直接使用方法区的Code cache中的机器码；没有机器码则判断计数器次数是否超过阈值，超过则触发编译，编译后机器码存储在方法区Code cache中使用；最后都没有就使用解释执行







### 基于栈的指令集与基于寄存器的指令集

javac编译出的字节码指令流是基于栈的指令集架构，与之对应的是PC机中物理硬件支持的指令集架构，依赖寄存器（基于寄存器的指令集）

> 基于寄存器的指令集

指令带参数，依赖寄存器来访问与存储数据



> 基于栈的指令集

指令通常不带参数，依赖栈，在栈中进行操作，结果也存储在操作栈中（也可能保存到局部变量表中）

优点:

1. 字节码指令紧凑（每个字节对应一个指令还不用带参数，基于寄存器的指令集需要带参数）
2. 实现简单（不用考虑分配内存问题，因为操作都是在栈中）
3. 可移植性

缺点: 因为实现同功能指令会比基于寄存器指令多，频繁的对栈进行操作（栈实现在内存中，实际上就是对内存进行操作）会影响速度



> 栈顶缓存 ToS (Top-of-Stack Cashing)

虚拟机使用的这种基于栈式的指令集，相对于基于寄存器的指令集来说，使用零地址指令更加紧凑，但是执行相同的任务(调用某个方法)会带来更多的入栈出栈操作，从而频繁读写内存，影响执行速度

**使用栈顶缓存技术，将栈顶元素全缓存在物理CPU寄存器中，以此降低对内存读写，提升效率**







### 总结

本篇文章将围绕执行引擎，深入浅出的解析执行引擎中的解释器、即时编译器各自执行的优缺点以及原理

**执行引擎由解释器、即时编译器、垃圾收集器构成，默认情况下使用解释器与编译器的混合方式执行**

**即时编译器分为C1、C2编译器，其中C1编译快但优化小，C2开启逃逸分析使用栈上分配、锁消除、标量替换进行优化，编译耗时但是优化大**

**即时编译器并不是所有代码都编译，而是使用方法技术和循环计数来将热点代码编译成机器码存放在方法区的Code Cache中**

**在混合执行的模式下，解释器、C1、C2编译器同时工作，分层编译**

**由于虚拟机使用基于栈的指令集，频繁操作效率会低于基于寄存器的指令集，同时使用栈顶缓存技术来提升效率**



### 最后

- 参考资料
	- 《深入理解Java虚拟机》
	- 部分图片来源于网络

本篇文章将被收入JVM专栏，觉得不错感兴趣的同学可以收藏专栏哟~

觉得菜菜写的不错，可以点赞、关注支持哟~

有什么问题可以在评论区交流喔~