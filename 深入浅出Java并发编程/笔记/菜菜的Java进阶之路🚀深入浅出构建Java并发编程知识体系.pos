{"diagram":{"elements":{"leftChildren":[],"note":"","watermark":"","children":[{"parent":"root","lineStyle":{"lineType":"curve","underLine":true,"randomLineColor":"#80BA4C","lineWidth":3},"children":[{"parent":"1fa4a37a81de","children":[{"parent":"edc9d0a59e6c7875","children":[{"parent":"4993fab9ac422470","children":[],"id":"63274dac023c6135","title":"分配资源的基本单位，管理资源"}],"id":"4993fab9ac422470","title":"进程"},{"parent":"edc9d0a59e6c7875","children":[{"parent":"7b01a241464bb62f","children":[],"id":"b29a7678a86be309","title":"多线程共享进程资源"},{"parent":"7b01a241464bb62f","children":[],"id":"3200f5447c8479bf","title":"执行调度的基本单位"},{"parent":"7b01a241464bb62f","children":[],"id":"d2b75005792ff5cf","title":"轻量级进程、用户线程"},{"parent":"7b01a241464bb62f","children":[{"parent":"8772477dffacf4a8","children":[{"parent":"51a05758b7f9fcb3","children":[],"id":"9dced6abbdc0ec2a","title":"限制上限"}],"id":"51a05758b7f9fcb3","title":"一对一"},{"parent":"8772477dffacf4a8","children":[{"parent":"a56308ad62ca4b36","children":[],"id":"abd6cedb6e697e41","title":"不限制上限，但线程阻塞时，对应该内核线程的所有用户线程都要阻塞"}],"id":"a56308ad62ca4b36","title":"一对多"},{"parent":"8772477dffacf4a8","children":[{"parent":"1d7644e1696a69a4","children":[],"id":"c6c451ac00b6e207","title":"复杂"}],"id":"1d7644e1696a69a4","title":"多对多"}],"id":"8772477dffacf4a8","title":"线程模型"}],"id":"7b01a241464bb62f","title":"线程"},{"parent":"edc9d0a59e6c7875","children":[{"parent":"a857abb4147fde63","children":[],"id":"1f19e1fd56a46000","title":"串行排队执行"}],"id":"a857abb4147fde63","title":"串行"},{"parent":"edc9d0a59e6c7875","children":[{"parent":"f2c4ab7837fb7112","children":[],"id":"6e58cc157a8b3e0b","title":"并行多核同时刻执行"}],"id":"f2c4ab7837fb7112","title":"并行"},{"parent":"edc9d0a59e6c7875","children":[{"parent":"2cfe80674022e9bc","children":[],"id":"672ab8403d38bd53","title":"线程交替执行，时刻上只有一个线程执行"}],"id":"2cfe80674022e9bc","title":"并发"}],"collapsed":true,"id":"edc9d0a59e6c7875","title":"概念"},{"parent":"1fa4a37a81de","children":[{"parent":"d6b4d57f328d6dc4","children":[],"id":"bdeba4b63c0edd74","title":"实现runnable 重写run"},{"parent":"d6b4d57f328d6dc4","children":[],"id":"d37e995c1ebe8a1d","title":"start 启动线程（OS创建线程）"}],"collapsed":false,"id":"d6b4d57f328d6dc4","title":"创建线程"},{"parent":"1fa4a37a81de","image":{"w":66,"h":45,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-651536425826544f8c098004?e=1695892562&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:1-oaccfzUSEXchIE5iMDwXTuzt0=","direction":"up"},"children":[{"parent":"a75b243dacb74628","children":[{"parent":"535bbf70c43ea443","children":[],"id":"c02963177c40922e","title":"创建线程"}],"id":"535bbf70c43ea443","title":"新建"},{"parent":"a75b243dacb74628","children":[{"parent":"eeeb32ba58e02821","children":[{"parent":"ac793039a8fab88b","children":[],"id":"d720eb7bbc558d3c","title":"线程准备好处CPU以外的所有资源"}],"id":"ac793039a8fab88b","title":"就绪"},{"parent":"eeeb32ba58e02821","children":[{"parent":"260aac9c00f5ce91","children":[],"id":"3c593c6331a1f175","title":"线程得到CPU资源开始运行"}],"id":"260aac9c00f5ce91","title":"运行中"}],"id":"eeeb32ba58e02821","title":"运行"},{"parent":"a75b243dacb74628","children":[{"parent":"2d1b93b829285f2f","children":[],"id":"5eef0a8f131bb14a","title":"获取锁失败 进入阻塞"}],"id":"2d1b93b829285f2f","title":"阻塞"},{"parent":"a75b243dacb74628","children":[{"parent":"83f06760d69e32e6","children":[],"id":"e5e59d35266105c3","title":"sleep&nbsp; 、 wait&nbsp; 进入等待，响应中断抛出异常 ；park 进入等待 不抛出异常"}],"id":"83f06760d69e32e6","title":"等待"},{"parent":"a75b243dacb74628","children":[{"parent":"421fdb2d7eecc47d","children":[],"id":"3b4896bf41a708fd","title":"sleep 、wait、parkNanos 设置超时时间"}],"id":"421fdb2d7eecc47d","title":"超时等待"},{"parent":"a75b243dacb74628","children":[{"parent":"28505ca022665e67","children":[],"id":"90cf322cbdbd49c9","title":"执行完调度 或 异常结束"}],"id":"28505ca022665e67","title":"终止"}],"collapsed":true,"id":"a75b243dacb74628","title":"线程状态"},{"parent":"1fa4a37a81de","children":[{"parent":"a2db68af3f95a4d1","children":[{"parent":"9c4a52ebb64b3f76","children":[],"id":"2ecbf25dc3f4b8b2","title":"多线程争抢共享资源时，加锁保证同步执行"}],"id":"9c4a52ebb64b3f76","title":"加锁同步"},{"parent":"a2db68af3f95a4d1","children":[{"parent":"1b3388cfac63ecae","children":[],"id":"9b7fa53b01bfb10b","title":"wait 等待"},{"parent":"1b3388cfac63ecae","children":[],"id":"b3e45b8a4d621cbc","title":"notify 通知"}],"id":"1b3388cfac63ecae","title":"等待通知"},{"parent":"a2db68af3f95a4d1","children":[],"id":"f5bbcdfba61e9f2c","title":"生产者消费者模型"},{"parent":"a2db68af3f95a4d1","children":[{"parent":"b2746a1f4b2c4bdc","children":[],"id":"a1d1d371b0808428","title":"while 代替 if 先判断再处理"}],"id":"b2746a1f4b2c4bdc","title":"虚假唤醒"}],"collapsed":false,"id":"a2db68af3f95a4d1","title":"线程通信"},{"parent":"1fa4a37a81de","children":[{"parent":"b6733a53107f","children":[{"parent":"e6162a216a4a15b4","children":[],"id":"446bb2c38cdd","title":"线程A.isInterrupted() 查看线程A的中断标记"},{"parent":"e6162a216a4a15b4","children":[],"id":"00a1793fd34f","title":"线程A.interrupt() 对线程A执行中断（false-&gt;true）"},{"parent":"e6162a216a4a15b4","children":[],"id":"f51857392c90","title":"Thread.interrupted() 查看当前线程的中断标记,清除当前线程中断标记(变为false)"}],"id":"e6162a216a4a15b4","title":"API"},{"parent":"b6733a53107f","children":[{"parent":"eb92bf4f6211bc55","children":[],"id":"1822612fbf3c594a","title":"线程运行时：轮询判断线程是否中断"},{"parent":"eb92bf4f6211bc55","children":[],"id":"a1510eb537000e04","title":"线程等待时（等待synchronized锁阻塞中断不会抛出异常）：受到中断会抛出异常，在捕获异常中Thread.interrupted()清除标记位，做终止前的清理操作，手动中断自己"}],"id":"eb92bf4f6211bc55","title":"优雅结束"}],"collapsed":false,"id":"b6733a53107f","title":"中断线程"}],"collapsed":true,"id":"1fa4a37a81de","title":"线程基础"},{"parent":"root","lineStyle":{"lineType":"curve","underLine":true,"randomLineColor":"#DD489D","lineWidth":3},"children":[{"parent":"36ea6654722e","children":[{"parent":"1391400d755a4855","children":[{"parent":"b70b0f5dcb096718","children":[],"id":"705944ed2f9c045e","title":"为了提升CPU利用率，会对不存在依赖关系的指令进行重排序，Java内存模型和先行先发生规则保证单线程下流程顺序，但无法确定多线程下执行顺序"}],"id":"b70b0f5dcb096718","title":"有序性"},{"parent":"1391400d755a4855","children":[{"parent":"11baee0b325b35be","image":{"w":91,"h":40,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-64e853971527cb05001f1900?e=1692950951&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:UHghkllOE0GQ9DaMwOrZ33_1wmA=","direction":"up"},"customWidth":601,"children":[],"id":"211dd37a682fc892","title":"Java内存模型采用共享内存模型，线程有自己的工作内存，从主内存中读取数据到工作内存中进行修改，最后再写回主内存；如果其他线程对该变量不可见，无法感知到变量被改变，就会继续使用自己工作内存中的脏数据"}],"id":"11baee0b325b35be","title":"可见性"},{"parent":"1391400d755a4855","children":[{"parent":"8f2d669312dbf814","children":[],"id":"9e9270198953eef7","title":"一组操作要么都成功要么都失败"}],"id":"8f2d669312dbf814","title":"原子性"}],"collapsed":false,"id":"1391400d755a4855","title":"前置"},{"parent":"36ea6654722e","children":[{"parent":"af1dc2abae8e","children":[],"id":"8400e18d1ec7","title":"禁止指令重排序保证有序性与可见性"},{"parent":"af1dc2abae8e","children":[],"id":"077d77c1fb50","title":"不保证复合操作的原子性"}],"collapsed":false,"id":"af1dc2abae8e","title":"特点"},{"parent":"36ea6654722e","children":[{"parent":"5ab575c2b0b9","children":[{"parent":"86b96077bb29","children":[{"parent":"2f7ec0e7ebd8ff99","children":[],"id":"9bc75788d188","title":"synchronized&nbsp;"},{"parent":"2f7ec0e7ebd8ff99","children":[],"id":"f56013aa14b68fbc","title":"JUC Lock"}],"id":"2f7ec0e7ebd8ff99","title":"悲观锁"},{"parent":"86b96077bb29","children":[{"parent":"a34cba170c7fda3f","children":[{"parent":"87bfe0f98243","children":[{"parent":"5eda58362d73","children":[],"id":"c68381e75b3e","title":"单核 不加lock前缀"},{"parent":"5eda58362d73","children":[],"id":"1fc7e7cda5ba","title":"多核 自动加lock前缀"}],"id":"5eda58362d73","title":"CAS由CMPXCHG指令实现"}],"id":"87bfe0f98243","title":"CAS+失败重试 非阻塞同步锁"}],"id":"a34cba170c7fda3f","title":"乐观锁"}],"id":"86b96077bb29","title":"Java实现原子操作"},{"parent":"5ab575c2b0b9","children":[{"parent":"29fba9b82a3f","children":[],"id":"20e5105dff50","title":"保证基本操作原子性"},{"parent":"29fba9b82a3f","children":[],"id":"1f795d2d0b5c877b","title":"复合操作(OS大多使用lock前缀命令实现)"}],"id":"29fba9b82a3f","title":"处理器实现原子操作"}],"collapsed":false,"id":"5ab575c2b0b9","title":"原子性实现原理"},{"parent":"36ea6654722e","children":[{"parent":"2ba26ece19bc","children":[{"parent":"cbb30ae09f91","children":[],"id":"fc11df0bc76b","title":"loadload barriers"},{"parent":"cbb30ae09f91","children":[],"id":"651f086ba8e5","title":"storestore barriers"},{"parent":"cbb30ae09f91","children":[],"id":"a432a3729e3e","title":"loadstore barriers"},{"parent":"cbb30ae09f91","children":[],"id":"072105bceff1","title":"storeload barriers 全能：禁止屏障上的写交换到下面，禁止屏障下的读交换到上面；先store写回内存，再load读数据"}],"id":"cbb30ae09f91","title":"内存屏障的分类"},{"parent":"2ba26ece19bc","children":[],"id":"bac932ba11fb","title":"volatile使用内存屏障（storeload）禁止指令重排序（保证可见性）"},{"parent":"2ba26ece19bc","children":[{"parent":"dc555f45554e","children":[{"parent":"ce290ca2b29d","children":[{"parent":"f090012811ce","children":[],"id":"30a5092b920f","title":"锁总线（开销大，只能一个处理器访问）"},{"parent":"f090012811ce","children":[],"id":"c3defffea8a4","title":"锁缓存（只锁住缓存行）+缓存一致性协议（保证没有多个处理器同时修改同一缓存的数据）"}],"id":"f090012811ce","title":"1. 从缓存中写回内存"},{"parent":"ce290ca2b29d","children":[],"id":"0273925ce05e","title":"2. 使用嗅探技术（保证内存缓存，其他处理器的缓存，在总线上一致），使其他处理器上的该缓存无效"}],"id":"ce290ca2b29d","title":"lock前缀指令的作用"}],"id":"dc555f45554e","title":"内存屏障storeload由lock前缀指令实现"}],"collapsed":false,"id":"2ba26ece19bc","title":"原理&nbsp;"},{"parent":"36ea6654722e","children":[{"parent":"d8e23de57491","image":{"w":306,"h":287,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-64e85472d53b113b84648962?e=1692951170&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:8HGq997rfujjZEhiOsPSr-cX_us=","direction":"up"},"children":[],"id":"dd0392badf7d","title":"共享的volatile变量处于同一个缓存行，处理器1修改i1，处理器2要重新读，处理器2修改i2，处理器1要重新读"},{"parent":"d8e23de57491","children":[{"parent":"a960457beccc","children":[],"id":"eab2eaf7aa57c857","title":"如果是64字节宽的处理器可以通过追加字节的方式，让这俩个volatile变量不在同一个缓存行&nbsp;"},{"parent":"a960457beccc","children":[],"id":"8240d5714ab1d5c6","title":"JDK8&nbsp;@sun.misc.Contended&nbsp;携带参数-XX:-RestrictContended"}],"id":"a960457beccc","title":"解决"}],"collapsed":false,"id":"d8e23de57491","title":"伪共享问题"},{"parent":"36ea6654722e","children":[{"parent":"fee7781f07a5e3f8","children":[{"parent":"567a0fd7216da44b","children":[{"parent":"e65d881885133f03","children":[{"parent":"e0b77b0bd384b4ce","children":[],"id":"f110a8ffbfb86cdb","title":"1. 分配内存"},{"parent":"e0b77b0bd384b4ce","children":[],"id":"d60040ea72f6eb31","title":"2. 初始化对象"},{"parent":"e0b77b0bd384b4ce","children":[],"id":"b40d1c43a61f173c","title":"3. 指针指向空间"},{"parent":"e0b77b0bd384b4ce","children":[],"id":"3331a7bb4045468d","title":"2，3不存在依赖关系可能重排序，导致其他线程获取到单例后未初始化对象"}],"id":"e0b77b0bd384b4ce","title":"创建对象"}],"id":"e65d881885133f03","title":"双重检测锁，修饰单例对象，禁止指令重排序，防止拿到未初始化的对象"}],"id":"567a0fd7216da44b","title":"有序性"},{"parent":"fee7781f07a5e3f8","children":[{"parent":"aaa2031f9fa199d2","children":[],"id":"eb9b1ffb3be62646","title":"并发场景下，配合读实现无锁操作"}],"id":"aaa2031f9fa199d2","title":"可见性"}],"collapsed":false,"id":"fee7781f07a5e3f8","title":"适用场景"}],"collapsed":true,"id":"36ea6654722e","title":"volatile"},{"parent":"root","lineStyle":{"lineType":"curve","underLine":true,"randomLineColor":"#FCB52A","lineWidth":3},"children":[{"parent":"a762fefda4c3","children":[{"parent":"75e8d7f9621af966","children":[],"id":"4d783307c07d3dec","title":"并发下保证同步"},{"parent":"75e8d7f9621af966","children":[],"id":"a4543c18faf0dfc2","title":"作用在代码块、方法上，可以锁对象或者静态对象，静态对象锁的是对应的Class对象"}],"id":"75e8d7f9621af966","title":"作用"},{"parent":"a762fefda4c3","lineStyle":{"lineType":"curve","underLine":true,"lineWidth":3},"children":[{"parent":"c92143450c5d96a3","children":[],"id":"c5812d4a41081f48","title":"比较并替换"},{"parent":"c92143450c5d96a3","children":[],"id":"dff60cae3316f0ab","title":"CAS+失败重试 实现乐观锁"},{"parent":"c92143450c5d96a3","children":[{"parent":"67d77ff8611117a6","children":[],"id":"4580942f4d500262","title":"以较小的开销在交替执行或竞争少的场景取代互斥量，如果在竞争大的场景不仅不容易拿到锁还会CPU空转"},{"parent":"67d77ff8611117a6","children":[],"id":"7ab695628b8254bb","title":"只能操作一个变量进行CAS，多变量需要封装成对象再使用对象引用的原子类"},{"parent":"67d77ff8611117a6","children":[],"id":"99d01551df11e570","title":"可能出现ABA问题，带时间戳、版本号自增进行校验，原子类解决"},{"parent":"67d77ff8611117a6","children":[],"id":"bfa525bb4fada82c","title":"不好预估自旋周期，自适应自旋解决"}],"id":"67d77ff8611117a6","title":"特点"}],"id":"c92143450c5d96a3","title":"CAS（实现、原子类）"},{"parent":"a762fefda4c3","children":[{"parent":"683d223b6ece","children":[{"parent":"9d9be0c113c7fcde","children":[],"id":"d68e2dc38ee4","title":"同步方法：访问标识ACC_SYNCHRONIZED"},{"parent":"9d9be0c113c7fcde","children":[],"id":"1558a55fe461","title":"同步块：monitorentry,monitorexit字节码指令"}],"id":"9d9be0c113c7fcde","title":"JVM实现"},{"parent":"683d223b6ece","children":[{"parent":"8ebc29c167ba7405","children":[{"parent":"44866bc36dbbc8ac","children":[],"id":"e36523450b243734","title":"cxq 竞争栈 + entry list 组成阻塞队列，避免aba问题"},{"parent":"44866bc36dbbc8ac","children":[],"id":"fc488fce4c6d6fa1","title":"waitset 组成等待队列"},{"parent":"44866bc36dbbc8ac","children":[],"id":"528ed50332fd647f","title":"object 要锁的对象"},{"parent":"44866bc36dbbc8ac","children":[],"id":"13317c7b300b8bdf","title":"owner 持有锁线程"},{"parent":"44866bc36dbbc8ac","children":[],"id":"df3ca69148d3f23d","title":"...."}],"collapsed":false,"id":"44866bc36dbbc8ac","title":"object monitor实现"},{"parent":"8ebc29c167ba7405","children":[{"parent":"a267a6151133","children":[{"parent":"ec9092db72b0","children":[{"parent":"c575ced50757","image":{"w":66,"h":29,"url":"http://cdn.processon.com/613f1ff71e08532eed6b6c8f?e=1631530525&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:mtB97OlU9vbz4cJ5LLSwKqpvNWc="},"children":[],"id":"9cd194e235c0","title":"mark word：存储一致性哈希码，GC分代年龄，锁信息等动态数据结构"},{"parent":"c575ced50757","children":[],"id":"3a8bc8b0cfd4","title":"类型指针：指向方法区存储该类信息的地址"},{"parent":"c575ced50757","children":[],"id":"6ae2ab0a0ae74628","title":"数组长度"}],"id":"c575ced50757","title":"对象头（8+4Byte）"},{"parent":"ec9092db72b0","children":[],"id":"afaf4779fc05","title":"实例数据"},{"parent":"ec9092db72b0","children":[],"id":"0cd470279509","title":"对齐填充"}],"collapsed":false,"id":"ec9092db72b0","title":"对象的组成"},{"parent":"a267a6151133","children":[{"parent":"1b9cbc872d15","children":[],"id":"e41fba678f62","title":"悲观锁：阻塞式同步锁（synchronized）"},{"parent":"1b9cbc872d15","children":[],"id":"4cacc0ab1921","title":"乐观锁：非阻塞式同步锁（CAS+失败重试）"}],"collapsed":false,"id":"1b9cbc872d15","title":"锁的分类"},{"parent":"a267a6151133","children":[{"parent":"27a5bb5c242f","children":[],"id":"a7aed4cb060de87b","title":"无锁"},{"parent":"27a5bb5c242f","children":[{"parent":"ab974ce2be35","children":[],"id":"24aad100256a","title":"由来：交替执行或竞争小情况下，减少使用互斥量的开销"},{"parent":"ab974ce2be35","children":[],"id":"c40e91be2449","title":"作用：对重量级锁进行优化（开销大），在没有竞争的情况下，使用CAS（开销小）；如果存在竞争开销=CAS+互斥量"},{"parent":"ab974ce2be35","children":[{"parent":"cf4a7b048745","children":[{"parent":"156fbb318fc7","children":[],"id":"7b4b22fc35cf","title":"Displaced Mark Word : 复制锁对象的mark word"},{"parent":"156fbb318fc7","children":[],"id":"f849acd01c28","title":"reference：获取锁时指向对象"}],"id":"156fbb318fc7","title":"锁记录"},{"parent":"cf4a7b048745","children":[{"parent":"032972beb891","image":{"w":56,"h":40,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-64edb72f86c5204b8196c8c4?e=1693304127&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:kh8oiFklN6vQFIfsq2pY2DRYR2A=","direction":"up"},"children":[],"id":"c785d3dfe9ac","title":"1.如果是无锁，在栈帧中创建锁记录并将对象的mark word复制到锁记录中"},{"parent":"032972beb891","image":{"w":49,"h":36,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-64edb7c7dd5be44e2479e186?e=1693304279&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:YKQPn-IbHUt-69AK9ZcP1I18OrU=","direction":"up"},"children":[],"id":"7d2908856326","title":"2. CAS将对象mark word替换为指向自己的锁记录，成功则获取锁成功"},{"parent":"032972beb891","image":{"w":57,"h":39,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-64edb85e835cbf7091b018b4?e=1693304430&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:lqzgZZ2AP3lvUS2TRrBYqeKPE28=","direction":"up"},"children":[],"id":"d4853121c794db22","title":"3. 如果持有锁，则判断获取锁的线程是不是当前线程，如果是则为重入的情况，复制null到锁记录，累加加锁次数"},{"parent":"032972beb891","image":{"w":59,"h":44,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-64edb8817e3221474c665e1e?e=1693304465&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:iETjXJNICwZQj5UY75i5MrT2YDI=","direction":"up"},"children":[],"id":"f9d41e693b008764","title":"4. 如果2中的CAS失败或者3中不是当前线程持有锁，则说明有竞争膨胀为重量级锁（生成object monitor对象，mark word指向它）"}],"id":"032972beb891","title":"加锁"},{"parent":"cf4a7b048745","children":[{"parent":"f6be3d00a1f8","children":[],"id":"8fa17b9a6bdc6164","title":"1. 查看锁记录复制内容是不是null，为空说明是重入，将获取锁次数扣减"},{"parent":"f6be3d00a1f8","children":[],"id":"43151d96d195015a","title":"2. 如果锁记录复制内容是mark word，则CAS替换回原对象的mark word中，成功则释放锁，失败则说明有竞争已膨胀，走重量级锁的释放流程"}],"id":"f6be3d00a1f8","title":"解锁"}],"collapsed":false,"id":"cf4a7b048745","title":"实现过程"}],"collapsed":false,"id":"ab974ce2be35","title":"轻量级锁"},{"parent":"27a5bb5c242f","children":[{"parent":"2294fed80ab4","children":[],"id":"672cfd6466e3","title":"目的：消除无竞争下的同步原语，减少开销"},{"parent":"2294fed80ab4","children":[],"id":"26264a0b732b","title":"作用：获取锁时连CAS都不用做了"},{"parent":"2294fed80ab4","image":{"w":49,"h":23,"url":"http://cdn.processon.com/614019d61efad46d32ea8f18?e=1631594470&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:4KQ3KR0O6UGEbPhY4htB37yaqnU="},"children":[{"parent":"32166d89a07d","children":[],"id":"938486e01b51","title":"锁对象偏向第一个获取锁的线程，CAS将锁对象mark word变为存储获取锁的线程ID，以后这个线程来获取锁都不用做同步原语"},{"parent":"32166d89a07d","children":[{"parent":"9daee34da71b","children":[],"id":"383102dc2ff6","title":"如果当前偏向的线程未获取锁，进入无锁状态"},{"parent":"9daee34da71b","children":[],"id":"bf2fd41d6fa6","title":"如果当前偏向的线程获取了锁，进入轻量级锁状态"}],"id":"9daee34da71b","title":"当有线程竞争时，退出偏向模式"}],"id":"32166d89a07d","title":"过程"},{"parent":"2294fed80ab4","children":[{"parent":"a39573f0a560","children":[{"parent":"8d57ff8274a8","children":[],"id":"eb0ba56710b4","title":"调用Object.hashCode()"},{"parent":"8d57ff8274a8","children":[],"id":"dc9be297fb81","title":"调用System.identityHashCode()"}],"id":"8d57ff8274a8","title":"计算一致性哈希后不使用偏向锁"},{"parent":"a39573f0a560","children":[],"id":"7b499b0005b8","title":"如果当前处于偏向锁模式，收到计算一致性哈希的请求会进入重量级锁（将一致性哈希存储在代表重量级锁的ObjectMonitor类中）"}],"id":"a39573f0a560","title":"不使用偏向锁的情况（计算完一致性哈希会保存在对象头中，偏向锁没地方存）"}],"collapsed":true,"id":"2294fed80ab4","title":"偏向锁"},{"parent":"27a5bb5c242f","children":[{"parent":"ba5e40413a97","children":[],"id":"299c9aa70a6e8afe","title":"竞争失败加入cxq栈进行自旋，释放锁时通知entry list首节点唤醒争抢，没有则将cxq栈加入entry list（先进后出）"},{"parent":"ba5e40413a97","children":[],"id":"ad06ea7a21c2ba0a","title":"wait 加入waitset; notify&nbsp;将waitset&nbsp;首节点&nbsp;加入cxq；释放锁时才唤醒entry list头节点(唤醒不一定抢得到，可能其他线程还在自旋)，entry list 为空就将cxq中节点加入再唤醒"},{"parent":"ba5e40413a97","children":[{"parent":"9b6e076282019bcc","children":[],"id":"071a40f2daab6fea","title":"已膨胀"},{"parent":"9b6e076282019bcc","children":[],"id":"443008de803adf0a","title":"膨胀中"},{"parent":"9b6e076282019bcc","children":[],"id":"97e0c5baf9d87139","title":"轻量级锁膨胀"},{"parent":"9b6e076282019bcc","children":[],"id":"6f37e38709537103","title":"无锁膨胀"}],"id":"9b6e076282019bcc","title":"膨胀"},{"parent":"ba5e40413a97","children":[{"parent":"b450390143074d29","children":[],"id":"c709836065811699","title":"固定自旋"},{"parent":"b450390143074d29","children":[],"id":"c426d1f209c9d9d8","title":"自适应自旋"}],"id":"b450390143074d29","title":"自旋"}],"collapsed":false,"id":"ba5e40413a97","title":"重量级锁"}],"collapsed":true,"id":"27a5bb5c242f","title":"锁状态"}],"collapsed":false,"id":"a267a6151133","title":"锁升级"},{"parent":"8ebc29c167ba7405","children":[{"parent":"e8539087f3e1","children":[],"id":"945db2c9c679","title":"进入安全点后，检查闲置的monitor 进行降级"}],"id":"e8539087f3e1","title":"锁降级"}],"id":"8ebc29c167ba7405","title":"C ++ 实现"}],"collapsed":false,"id":"683d223b6ece","title":"实现"}],"collapsed":true,"id":"a762fefda4c3","title":"synchronized"},{"parent":"root","lineStyle":{"lineType":"curve","underLine":true,"randomLineColor":"#0F80C4","lineWidth":3},"children":[{"parent":"5122f903f0ed","children":[],"id":"9f3984bc4a7e","title":"JUC下的锁使用AQS来完成，AQS提供了一系列获取/释放锁的模板方法，要实现不同功能的组件只需要重写同步获取/释放锁的方法"},{"parent":"5122f903f0ed","children":[{"parent":"3ce4dd36c07b","children":[{"parent":"058878c62cfe","children":[],"id":"342febef79f2","title":"AQS的同步状态类似锁（资源）"},{"parent":"058878c62cfe","image":{"w":62,"h":55,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-64f184825af8cd614aeb8eb9?e=1693553298&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:TcFwxYT0Kil4H9abd1zVf-YVDXo=","direction":"up"},"children":[{"parent":"a3d7a2a367f9","children":[],"id":"67b3f2d37d3c","title":"节点状态"},{"parent":"a3d7a2a367f9","children":[],"id":"a3c217edd2a1","title":"对应的线程"},{"parent":"a3d7a2a367f9","children":[],"id":"83b5cf7912e1","title":"前驱节点，后继节点指针"},{"parent":"a3d7a2a367f9","children":[],"id":"2b3390dfd07bffa7","title":"等待队列时的后继节点指针"}],"id":"a3d7a2a367f9","title":"节点信息"},{"parent":"058878c62cfe","children":[{"parent":"f4594b3fa79d","image":{"w":68,"h":45,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-64f1845a53d13c189b317095?e=1693553258&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:9QiWeQq7fpxEPQGrCm87eZiOoCQ=","direction":"up"},"children":[],"id":"abedaf9fe166","title":"当线程获取同步状态失败，将该线程封装成节点，CAS+失败重试将它加入同步队列的队尾"},{"parent":"f4594b3fa79d","image":{"w":81,"h":38,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-64f18464cb0a785a0901a502?e=1693553269&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:wfOVuX_hi3IVxFDcZHUQUq4q6Dw=","direction":"up"},"children":[],"id":"8bc8d9ad2466","title":"同步队列的队首节点获取同步状态成功，当它释放时会唤醒后继节点，若后继节点成功获取同步状态，则后继节点成为新的队首节点（设置队首节点不需要CAS，因为它已经获取同步状态了）"}],"collapsed":false,"id":"f4594b3fa79d","title":"同步队列上的节点存储着获取同步状态失败的线程信息"},{"parent":"058878c62cfe","children":[{"parent":"4cd7f633f5c5","children":[{"parent":"58e7767f84c9","image":{"w":85,"h":42,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-64f184c3cb0a785a0901a50b?e=1693553363&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:N2gGO1htOJasanxilP0JHcGUMbs=","direction":"up"},"children":[{"parent":"2db4b9a3e577","children":[],"id":"35351d032b54","title":"尝试获取锁，成功则获取锁成功"},{"parent":"2db4b9a3e577","children":[{"parent":"4efaed3136c4","children":[],"id":"bd2e157f2cd9","title":"addWaiter(Node)&nbsp;封装节点CAS+失败重试加入同步队列队尾"},{"parent":"4efaed3136c4","children":[],"id":"d45e43945927","title":"acquireQueued(Node,int) 开始自旋（自旋的CAS失败会被park,进入等待状态,等待前驱唤醒），直到满足：前驱节点是队首节点+CAS成功获取到同步状态才退出循环"}],"id":"4efaed3136c4","title":"失败"}],"id":"2db4b9a3e577","title":"获取 acquire"},{"parent":"58e7767f84c9","children":[{"parent":"d534205372a6","children":[],"id":"f0e859474fa0","title":"释放同步状态，唤醒后继节点"}],"id":"d534205372a6","title":"释放 release"}],"id":"58e7767f84c9","title":"独占锁的获取与释放"},{"parent":"4cd7f633f5c5","children":[{"parent":"ca956700d93f5b38","children":[],"id":"e3c1982736563a45","title":"在唤醒时检查中断标识，如果被中断则抛出中断异常；非响应中断是在外层自己中断"}],"id":"ca956700d93f5b38","title":"响应中断"},{"parent":"4cd7f633f5c5","children":[{"parent":"e635e4afdff8","children":[],"id":"688c4259d51472b3","title":"响应中断"},{"parent":"e635e4afdff8","children":[{"parent":"6c205ead7e9b","children":[],"id":"2c0813819878","title":"如果超时了就退出"},{"parent":"6c205ead7e9b","children":[],"id":"b849d143bbea","title":"如果没超时，剩下的等待时间大于1000ns&nbsp;就&nbsp;park进入等待；否则直接自旋"}],"id":"6c205ead7e9b","title":"在独占锁的基础上在自旋时增加了超时判断"}],"id":"e635e4afdff8","title":"响应超时"},{"parent":"4cd7f633f5c5","children":[{"parent":"a478b9d4af8d","children":[],"id":"f878ca19aebb","title":"获取/释放逻辑与独占式类似，只不过获取失败时，封装节点为共享式"}],"id":"a478b9d4af8d","title":"共享锁的获取与释放"}],"collapsed":false,"id":"4cd7f633f5c5","title":"关于锁的获取与释放"},{"parent":"058878c62cfe","children":[{"parent":"bf1a209aea8b","children":[],"id":"43c76a18f415","title":"第一次调用获取锁的方法时，先尝试获取锁，获取不到才加入同步队列中，在同步队列中就是FIFO的顺序了"},{"parent":"bf1a209aea8b","children":[],"id":"c11e51c7d26e","title":"而公平锁在第一次调用获取锁方法时，会先判断前驱节点是不是首节点/首节点是不是为空，只有满足这个条件才尝试获取锁，否则构建节点加入队尾"}],"id":"bf1a209aea8b","title":"问题：AQS维护的同步队列是FIFO的，是怎么实现非公平呢？"}],"collapsed":true,"id":"058878c62cfe","title":"AQS同步队列（FIFO）"},{"parent":"3ce4dd36c07b","children":[{"parent":"94fec3f53749c1b9","children":[],"id":"5475382acf0e","title":"AQS有个内部类ConditionObject（它是等待队列，想要多少个等待队列就创建多少个这个对象，使用它前要获取锁，所以它是AQS的内部类）"},{"parent":"94fec3f53749c1b9","children":[],"id":"061f672ad731","title":"Object监视器模型使用一个等待队列和一个同步队列，当在某个锁对象上调用wait时该线程进入等待队列，调用notify时进入同步队列，未获取到锁的线程阻塞在同步队列"},{"parent":"94fec3f53749c1b9","image":{"w":57,"h":73,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-64f185a4d53b113b8464cccf?e=1693553588&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:xNXFdpO80SPwzhFnkySEGgSxi6I=","direction":"up"},"children":[],"id":"81512d0fdf83","title":"AQS监视器模型使用一个同步队列和多个等待队列"},{"parent":"94fec3f53749c1b9","children":[{"parent":"8400547a8b1e","children":[{"parent":"7e86354f5217","children":[],"id":"a0c5d3bee027","title":"获取锁的线程（同步队列对头节点）释放锁，构建节点进入等待队列队尾"}],"id":"7e86354f5217","title":"await"},{"parent":"8400547a8b1e","children":[{"parent":"e131bf98e617","children":[],"id":"8fa9d2e1ae7e","title":"唤醒等待队列队首线程，等待队列队头节点加入（CAS）到同步队列队尾"}],"id":"e131bf98e617","title":"signal"}],"id":"8400547a8b1e","title":"ConditionObject实现Condition接口，与JUC下的锁（实现AQS的组件）搭配使用可实现Object中wait/notify+synchronized"}],"collapsed":false,"id":"94fec3f53749c1b9","title":"Condition"}],"id":"3ce4dd36c07b","title":"实现"}],"collapsed":true,"id":"5122f903f0ed","title":"AQS&nbsp;"},{"parent":"root","lineStyle":{"lineType":"curve","underLine":true,"randomLineColor":"#0FBAB0","lineWidth":3},"children":[{"parent":"d02a66613283","children":[],"id":"aa9b18270f72","title":"提供park，unpark公共静态方法来让线程 等待/唤醒，底层调用unsafe类的本地方法"},{"parent":"d02a66613283","children":[],"id":"da353782f4c17bb1","title":"park 提供由于哪个对象而阻塞，方便排查"}],"collapsed":true,"id":"d02a66613283","title":"LockSupport工具"},{"parent":"root","lineStyle":{"lineType":"curve","underLine":true,"randomLineColor":"#7549C5","lineWidth":3},"children":[{"parent":"c7cb0c29add2","children":[{"parent":"58349bfc8e7d","children":[],"id":"afabb0a554c5f428","title":"JUC下的独占式可重入锁，能够实现synchronized的所有功能外还提供响应中断、超时、公平的特性"},{"parent":"58349bfc8e7d","children":[],"id":"5ef0191c9abe","title":"想要实现重入锁，只需要使用变量保存获取锁的线程，再下次尝试获取锁时，判断当前线程与获取锁的线程是否相同来判断是否可重入"},{"parent":"58349bfc8e7d","children":[],"id":"5e059b6e14f8","title":"公平锁获取锁的逻辑与非公平类似，只不过公平锁在第一次获取锁时会先判断前驱节点是否为首节点（或者首节点是否为空）只有成功了才会尝试获取锁"},{"parent":"58349bfc8e7d","children":[{"parent":"72ff40a8e807","children":[],"id":"08ce4a49cc73","title":"如果同步状态为0，说明没获取锁，CAS尝试获取锁"},{"parent":"72ff40a8e807","children":[{"parent":"779941638afd","children":[],"id":"66231c833853","title":"是当前线程则可以获取，同步状态+1"},{"parent":"779941638afd","children":[],"id":"0020279350d9","title":"不是当前线程则获取失败"}],"id":"779941638afd","title":"如果同步状态不为0，说明已经获取过锁了，判断获取锁的线程是否为当前线程"}],"id":"72ff40a8e807","title":"ReentrantLock重写AQS中获取同步状态的逻辑（非公平锁）"},{"parent":"58349bfc8e7d","children":[{"parent":"67ec8f9aba6d","children":[],"id":"35cebd8f8b5e","title":"判断当前线程是否为获取锁的线程，不是则抛出异常"},{"parent":"67ec8f9aba6d","children":[],"id":"38c6fe2779a6","title":"自减同步状态，只有同步状态为0时，才是真正释放了锁，设置获取锁的线程为null，返回true"}],"id":"67ec8f9aba6d","title":"ReentrantLock重写AQS中释放同步状态的逻辑"}],"collapsed":true,"id":"58349bfc8e7d","title":"reentrant lock 重入锁"},{"parent":"c7cb0c29add2","children":[{"parent":"bb57701697d6","image":{"w":112,"h":29,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-64f47d287e3221474c668ae8?e=1693748024&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:9urq6a3Av2GAgN9DLJe6bxAZ2Ao=","direction":"up"},"children":[],"id":"5a5e375c8f1f","title":"int同步状态：高16位当读锁的同步状态；低16位当写锁的同步状态"},{"parent":"bb57701697d6","children":[{"parent":"b3dcd5e7665f","children":[],"id":"4ddc0426cb9e","title":"读锁是共享锁，写锁是独占锁；多个共享锁一起读不会阻塞，细粒度更大，多读少写的场景性能更好"},{"parent":"b3dcd5e7665f","children":[],"id":"cb94e25e762c","title":"有读锁时，不能获取写锁"},{"parent":"b3dcd5e7665f","children":[],"id":"a4763b050c7b","title":"有读锁时可以再次获取读锁"},{"parent":"b3dcd5e7665f","children":[],"id":"e74d33de8652","title":"有写锁时,只能获取写锁的线程获取读锁"},{"parent":"b3dcd5e7665f","children":[{"parent":"aa36fbaa27e4","children":[],"id":"5025aaf4dce3","title":"如果不获取读锁,释放写锁后,其他线程又获取写锁修改了这个数据,使用数据时会出现脏读(不知道被修改了)"}],"id":"aa36fbaa27e4","title":"锁降级：获取写锁-&gt;再获取读锁-&gt;释放写锁-&gt;使用数据-&gt;释放读锁"}],"id":"b3dcd5e7665f","title":"特点"},{"parent":"bb57701697d6","children":[{"parent":"fbd11d6a3fcc","children":[],"id":"49023d451518","title":"如果同步状态为0,说明读写锁都未获取,CAS设置同步状态,获取写锁成功(设置获取独占锁线程为当前线程[可重入的关键])"},{"parent":"fbd11d6a3fcc","children":[],"id":"99bbec373428","title":"如果同步状态不为0,只有当读状态为0,当前线程是获取独占锁的线程才能获取成功,否则失败"}],"id":"fbd11d6a3fcc","title":"写锁的获取"},{"parent":"bb57701697d6","children":[{"parent":"e206b57cc820","children":[],"id":"89ae092c7d0c","title":"如果其他线程获取了写锁,则失败"},{"parent":"e206b57cc820","children":[],"id":"260c0f19e1d5","title":"如果获取写锁的是当前线程,则CAS更新同步状态,获取读锁成功（锁降级）"}],"id":"e206b57cc820","title":"读锁的获取"}],"collapsed":true,"id":"bb57701697d6","title":"reentrant read write lock 读写锁"},{"parent":"c7cb0c29add2","children":[{"parent":"a1d18c23f6c7f043","children":[],"id":"06ca5095b754257a","title":"初始化同步状态数量 countdown 释放1个可中断共享锁 ，await 阻塞直到同步状态为0"}],"id":"a1d18c23f6c7f043","title":"count down latch"},{"parent":"c7cb0c29add2","children":[{"parent":"96a8463d802ab65c","children":[],"id":"d0f0ad2450deabf3","title":"初始化同步状态数量 ， 使用共享锁"}],"id":"96a8463d802ab65c","title":"semaphore"},{"parent":"c7cb0c29add2","children":[{"parent":"4c447f42c93c6ae3","children":[],"id":"13678f7278c5c255","title":"使用reentrant lock&nbsp; + 代 ，重置计数器复用"}],"id":"4c447f42c93c6ae3","title":"CyclicBarrier"},{"parent":"c7cb0c29add2","children":[{"parent":"da9605fe9f7e1d07","children":[],"id":"d7d622d9ccb9e396","title":"线程协作交换，阻塞直到两个线程都到达同步点进行交换"}],"id":"da9605fe9f7e1d07","title":"Exchanger"}],"collapsed":true,"id":"c7cb0c29add2","title":"常用同步组件"},{"parent":"root","lineStyle":{"lineType":"curve","underLine":true,"randomLineColor":"#0D7C82","lineWidth":3},"children":[{"parent":"4c53362488e8ff27","children":[{"parent":"7aeb85f57f091b27","children":[],"id":"07eca6d4262b8eb6","title":"复用资源，避免频繁创建与销毁、提高响应、方便管理"},{"parent":"7aeb85f57f091b27","children":[],"id":"0388e4e81da97e85","title":"线程池、连接池"}],"collapsed":false,"id":"7aeb85f57f091b27","title":"池化技术"},{"parent":"4c53362488e8ff27","children":[{"parent":"c82b684dae88b520","children":[],"id":"4e7ecec1810a340d","title":"将任务与线程池执行分离"},{"parent":"c82b684dae88b520","children":[],"id":"6565a6b1056de5e3","title":"线程池顶层接口，定义执行runnable任务方法"}],"collapsed":false,"id":"c82b684dae88b520","title":"Executor"},{"parent":"4c53362488e8ff27","children":[{"parent":"42626d05e0a2a18f","children":[{"parent":"da8e2ef601dd3336","children":[],"id":"5ea114fdeef6dd12","title":"runnable 无返回值任务"},{"parent":"da8e2ef601dd3336","children":[{"parent":"adf7872c9bfa521d","children":[],"id":"48565b368bbfe2b4","title":"由于executor接口只提供执行runnable任务方法，想执行callable任务时，通常使用实现类FutureTask"},{"parent":"adf7872c9bfa521d","children":[],"id":"f801ec58db4d0d99","title":"FutureTask 实现Runnable 且字段保存callable，在实现runnable中是去执行callable任务，相当于适配器"}],"id":"adf7872c9bfa521d","title":"callable 有返回值任务"}],"collapsed":false,"id":"da8e2ef601dd3336","title":"执行任务"},{"parent":"42626d05e0a2a18f","children":[{"parent":"6a00f1430c12759d","children":[],"id":"37c8f9f56e3e7d70","title":"核心线程数"},{"parent":"6a00f1430c12759d","children":[],"id":"e4f8f8fddbeae061","title":"最大线程数"},{"parent":"6a00f1430c12759d","children":[],"id":"98c195c92263e0bd","title":"等待时间、时间单位"},{"parent":"6a00f1430c12759d","children":[],"id":"d0fdb47258b4cee8","title":"阻塞队列"},{"parent":"6a00f1430c12759d","children":[],"id":"41308dd0c80c73d1","title":"线程工厂"},{"parent":"6a00f1430c12759d","children":[{"parent":"c03df7fbe12584fc","children":[],"id":"15cc985408ab25ee","title":"默认抛出异常"},{"parent":"c03df7fbe12584fc","children":[],"id":"3d365194b54014a3","title":"调用者处理"},{"parent":"c03df7fbe12584fc","children":[],"id":"8a833d1641a92130","title":"不处理 丢弃"},{"parent":"c03df7fbe12584fc","children":[],"id":"9c5b1a64638dc9cc","title":"丢弃队列中最近的任务，立即执行当前任务"}],"id":"c03df7fbe12584fc","title":"拒绝策略"}],"collapsed":false,"id":"6a00f1430c12759d","title":"核心参数"},{"parent":"42626d05e0a2a18f","image":{"w":81,"h":26,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-64fe6d2cb817e458f5162a0b?e=1694399293&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:RY4Y6NWwZcOonTsDhOszQHkMZig=","direction":"up"},"children":[{"parent":"b85e71d34f3e2930","children":[],"id":"681b32caf950243c","title":"如果当前线程数 小于 核心线程数则创建线程（即使有空闲线程也创建，相当于预热）全局锁"},{"parent":"b85e71d34f3e2930","children":[],"id":"1980ecd5af62594f","title":"如果当前线程数 大于等于 核心线程数 小于 最大线程数，并且阻塞队列没满 ，任务加入阻塞队列"},{"parent":"b85e71d34f3e2930","children":[],"id":"944b63f46806b921","title":"如果当前线程数 大于等于 核心线程数 小于 最大线程数，并且阻塞队列已满，创建新线程执行任务"},{"parent":"b85e71d34f3e2930","children":[],"id":"844567bd1de76466","title":"如果当前线程数 等于 最大线程数，阻塞队列已满，使用拒绝策略"},{"parent":"b85e71d34f3e2930","children":[],"id":"88364b40a5b98d61","title":"（当非核心线程超过空闲时间则关闭）"}],"collapsed":false,"id":"b85e71d34f3e2930","title":"工作流程"},{"parent":"42626d05e0a2a18f","children":[{"parent":"bcfc053169ba9491","children":[{"parent":"6f525550fc33dade","children":[],"id":"755580332feb8351","title":"CPU密集：N+1"},{"parent":"6f525550fc33dade","children":[],"id":"93ee535b8ee6d0b5","title":"IO密集：2N"}],"collapsed":true,"id":"6f525550fc33dade","title":"最大线程数量"}],"id":"bcfc053169ba9491","title":"配置参数"},{"parent":"42626d05e0a2a18f","children":[{"parent":"15a0b4e37773ab57","children":[],"id":"a9f58a28b8b4b88a","title":"对任务进行捕获"},{"parent":"15a0b4e37773ab57","children":[],"id":"36773633de883b52","title":"对callable任务再获取返回值时进行捕获"},{"parent":"15a0b4e37773ab57","children":[],"id":"96b9632fc0a1111c","title":"继承线程池，在执行完任务后 记录日志 兜底"},{"parent":"15a0b4e37773ab57","children":[],"id":"ecef1dd864db9a0d","title":"自定义线程工厂，创建线程时设置未捕获方法"}],"id":"15a0b4e37773ab57","title":"处理异常"},{"parent":"42626d05e0a2a18f","children":[{"parent":"6cfd7b6b07bcb8f1","children":[],"id":"924df62bd76bf3a3","title":"shutdown 关闭线程池，等待正在执行的任务"},{"parent":"6cfd7b6b07bcb8f1","children":[],"id":"8452ca7375bffb57","title":"shutdown now 立马关闭，包括正在执行的线程"}],"id":"6cfd7b6b07bcb8f1","title":"关闭线程池"}],"collapsed":true,"id":"42626d05e0a2a18f","title":"ThreadPoolExecutor"},{"parent":"4c53362488e8ff27","children":[{"parent":"67d4d7cd48f5e130","children":[],"id":"807922a39b2de2ef","title":"在ThreadPoolExecutor基础上实现定时任务的线程池"},{"parent":"67d4d7cd48f5e130","lineStyle":{"lineColor":"#7549C5","lineWidth":3},"children":[],"style":{"lineStype":{"lineColor":"#7549C5","lineWidth":3},"padding":"5px 9px","blob":true,"color":"#0D0B22","lineStyle":{"lineColor":"#7549C5","lineWidth":3},"textAlign":"left","font-weight":"400","font-size":"13px","font-family":"微软雅黑","font-style":"normal"},"id":"d8ffb89ecf907770","title":"scheduleAtFixedRate&nbsp;以任务开始为周期起点<br>"},{"parent":"67d4d7cd48f5e130","children":[],"id":"c39e729fb05233ed","title":"scheduledWithFixedDelay&nbsp;以任务结束为周期起点"}],"collapsed":true,"id":"67d4d7cd48f5e130","title":"SecheduledThreadPoolExecutor"}],"collapsed":true,"id":"4c53362488e8ff27","title":"线程池"},{"parent":"root","lineStyle":{"lineType":"curve","underLine":true,"randomLineColor":"#FD5155","lineWidth":3},"children":[{"parent":"694a834e5f5006d4","children":[{"parent":"dd24699a9fd72418","children":[],"id":"25156149fd507d86","title":"有界 默认需要初始化容量"},{"parent":"dd24699a9fd72418","children":[],"id":"002e3f8fc6ab0307","title":"无界 默认最大整形为容量，队列太多元素时可能OOM"}],"id":"dd24699a9fd72418","title":"有界与无界"},{"parent":"694a834e5f5006d4","children":[{"parent":"e2b95e148c7a34fc","children":[],"id":"0e647ec42bc48b4a","title":"由队列的锁来保证是否公平"}],"id":"e2b95e148c7a34fc","title":"公平与非公平"},{"parent":"694a834e5f5006d4","children":[{"parent":"9f9a87505ea578c2","children":[{"parent":"20bcbc0fe589a033","children":[],"id":"559bc1281ed87273","title":"环形数组、固定容量、一把锁、两个等待队列操作队头、队尾，适合小并发场景"}],"id":"20bcbc0fe589a033","title":"ArrayBlockingQueue"},{"parent":"9f9a87505ea578c2","children":[{"parent":"140d6e238398","children":[],"id":"4ff53156e6eb","title":"单向链表、首尾节点、两把锁和两个等待队列，分别操作队头，队尾，在入队、出队期间还去唤醒生产、消费线程，并发性能好<br>"}],"id":"140d6e238398","title":"LinkedBlockingQueue"},{"parent":"9f9a87505ea578c2","children":[{"parent":"fb83249e9b20886e","children":[],"id":"682b0f9f86aecd6a","title":"双向队列，在linkedblockqueue基础上队头、队尾都可以入队、出队操作，适合充当工作窃取算法"}],"id":"fb83249e9b20886e","title":"LinkedBlockingDequq"},{"parent":"9f9a87505ea578c2","children":[{"parent":"b23ced7e1ce5c2eb","children":[],"id":"a87163425f1e9d52","title":"优先级阻塞队列"},{"parent":"b23ced7e1ce5c2eb","children":[],"id":"1f0366afa43418a0","title":"根据元素实现的比较规则 或者 比较器 进行排序"},{"parent":"b23ced7e1ce5c2eb","children":[],"id":"d2fdc665a47ca9ee","title":"适合在优先级执行任务场景使用"}],"id":"b23ced7e1ce5c2eb","title":"PriorityBlockingQueue&nbsp;"},{"parent":"9f9a87505ea578c2","children":[{"parent":"e40cdb3b24264939","children":[],"id":"5c4277776b6dc57e","title":"延迟队列"},{"parent":"e40cdb3b24264939","children":[],"id":"965087ec381789f5","title":"元素要实现那Delayed接口 返回延时时间"},{"parent":"e40cdb3b24264939","children":[],"id":"4fff7e0a2777763e","title":"适合在缓存过期、定时任务场景使用"}],"id":"e40cdb3b24264939","title":"DelayQueue&nbsp;"},{"parent":"9f9a87505ea578c2","children":[{"parent":"322ef74255f877e6","children":[],"id":"746898e45813a205","title":"不存储元素，传递性场景使用，多对多，线程间传递数据"}],"id":"322ef74255f877e6","title":"SynchronousQueue"},{"parent":"9f9a87505ea578c2","children":[{"parent":"38601153b66178e1","children":[],"id":"2f9e3c74a0672814","title":"传输形场景，一对一"}],"id":"38601153b66178e1","title":"LinkedTransferQueue"}],"collapsed":false,"id":"9f9a87505ea578c2","title":"实现类型"}],"collapsed":true,"id":"694a834e5f5006d4","title":"阻塞队列"},{"parent":"root","lineStyle":{"lineType":"curve","underLine":true,"randomLineColor":"#02ACF4","lineWidth":3},"children":[{"parent":"f9d0d3b631c2","children":[{"parent":"6a9653a0a8a7","children":[{"parent":"4100ba10e37cd061","children":[],"id":"4efb85d54dc9fa14","title":"ArrayList 使用快速失败，在并发读写场景下抛出并发修改异常"},{"parent":"4100ba10e37cd061","children":[{"parent":"66cd4046d3af1b71","children":[],"id":"fee1d1454aadf369","title":"Vertor&nbsp;"},{"parent":"66cd4046d3af1b71","children":[],"id":"d582e4fdcae39d67","title":"Collections.synchronized"},{"parent":"66cd4046d3af1b71","children":[],"id":"8b9db004448d9b45","title":"COWArrayList"}],"id":"66cd4046d3af1b71","title":"解决方案"}],"id":"4100ba10e37cd061","title":"背景"},{"parent":"6a9653a0a8a7","children":[{"parent":"f4d2add206d1f5c6","children":[],"id":"52c14ba3591ad56a","title":"<u>环形数组，固定容量</u>"},{"parent":"f4d2add206d1f5c6","children":[],"id":"404f8e726679f3cf","title":"读时volatile保证可见性，写时复制数组，写完再设置回去，频繁写拷贝开销大"},{"parent":"f4d2add206d1f5c6","children":[],"id":"7484791b2b9ffb74","title":"使用迭代器时，会使用数据创建新对象来迭代，可能不是最新数据，弱一致性"},{"parent":"f4d2add206d1f5c6","children":[],"id":"760dabe1788d608d","title":"适合数据量小，读多写少，弱一致性的场景"}],"id":"f4d2add206d1f5c6","title":"特点"}],"collapsed":false,"id":"6a9653a0a8a7","title":"CopyOnWriteArrayList"},{"parent":"f9d0d3b631c2","children":[{"parent":"04facd0443b1","children":[],"id":"421da12f13d0","title":"ConcurrentLinkedQueue的入队出队与LinkedBlockingQueue类似，也使用了哨兵节点；但ConcurrentLinkedQueue采用CAS+失败重试的方式实现非阻塞式的线程安全队列（LinkedBlockingQueue使用悲观锁）并且concurrent&nbsp;linked&nbsp;queue使用了延迟首尾节点的思想来减少CAS的次数<br>"},{"parent":"04facd0443b1","children":[{"parent":"d19e29885939fe43","children":[{"parent":"7484a6570582","children":[],"id":"abde6409ab5d037b","title":"在循环中找到真正的尾节点，CAS添加新节点，再判断是否更新尾节点tail"},{"parent":"7484a6570582","children":[],"id":"6d01ab98eedca11b","title":"在循环中一般是向后遍历节点，直到找到真正尾节点；但由于出队会构建成环哨兵节点，遇到这种情况要跳出，定位到头或尾节点的队列上"}],"id":"7484a6570582","title":"入队"},{"parent":"d19e29885939fe43","children":[{"parent":"73852829a426","children":[],"id":"36463ff9ae7949ec","title":"在循环中找到真正头节点，CAS将数据设置为空，再判断是否更新头节点head，如果更新则 将旧的head构建成成环的哨兵节点"},{"parent":"73852829a426","children":[],"id":"08bc61d73e43d3fd","title":"在循环中一般也是向后遍历，直到找到真正头节点；但可能其他线程出队构建成环哨兵节点，因此这种情况也要跳出（跳过本次循环），重进入循环跳到新的头节点上"}],"id":"73852829a426","title":"出队"}],"id":"d19e29885939fe43","title":"实现"},{"parent":"04facd0443b1","children":[{"parent":"1ff4125d28b01dc6","children":[],"id":"cbb7c4318e276345","title":"单向链表组成的队列，记录首尾节点"},{"parent":"1ff4125d28b01dc6","children":[],"id":"f73bf02f878cefda","title":"读时volatile保证数据可见性，写时使用乐观锁 CAS+失败重试 无阻塞"},{"parent":"1ff4125d28b01dc6","children":[],"id":"960b6ab8c1bae5af","title":"延迟CAS更新首尾节点，减少CAS次数，提升性能"},{"parent":"1ff4125d28b01dc6","children":[],"id":"06ab627056943526","title":"哨兵节点降低代码复杂度，避免一个节点竞争"},{"parent":"1ff4125d28b01dc6","children":[],"id":"10a0de40ebcc4477","title":"适合数据量大、并发量高、频繁读写操作队头、队尾的场景"}],"id":"1ff4125d28b01dc6","title":"特点"}],"collapsed":false,"id":"04facd0443b1","title":"ConcurrentLinkedQueue"},{"parent":"f9d0d3b631c2","children":[{"parent":"b48bd81777b4","children":[{"parent":"50d22100f231","children":[],"id":"0daafe377947","title":"1.7的HashMap使用头插法在并发扩容时会出现死链（并发死链）"},{"parent":"50d22100f231","children":[],"id":"99a0655feff1","title":"1.8虽然改用尾插法但在并发下还是有问题"}],"id":"50d22100f231","title":"HashMap"},{"parent":"b48bd81777b4","children":[{"parent":"5d990abd7dfbc6d8","children":[{"parent":"a10de682da54","children":[{"parent":"8b5ca149d29a","children":[],"id":"e1cb2cb3c9df","title":"定位segment：将哈希值在扩散后，使用segmentshift 来右移,再与运算segment mask （高位计算）"},{"parent":"8b5ca149d29a","children":[],"id":"d30b82ea6b8e","title":"get: 无锁 volatile保证可见性"},{"parent":"8b5ca149d29a","children":[],"id":"a3e0020be8c1","title":"put: 定位到segment 再获取锁 ，替换/添加 hash entry （判断是否需要扩容）"},{"parent":"8b5ca149d29a","children":[],"id":"7837b36a38a4","title":"扩容：构建新的hash entry数组，在原索引的迁移，不在的在新hash entry上构建新节点"},{"parent":"8b5ca149d29a","children":[],"id":"c99d09af161b","title":"计算size : 先不加锁的情况，统计每个segment的元素个数与modcount（写操作计数），如果相同则直接返回；不同说明有并发，重新统计；重新统计超过3次使用全局锁（所有segment加锁）"}],"collapsed":true,"id":"8b5ca149d29a","title":"采用segment分段锁 + hash entry数组（数组+链表）"}],"id":"a10de682da54","title":"JDK7"},{"parent":"5d990abd7dfbc6d8","children":[{"parent":"da8f3e1c78ce","image":{"w":129,"h":68,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-6513a687c695386156796198?e=1695790231&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:maNzG4gUZ036IFRF6zmHUmY5C6U=","direction":"up"},"children":[{"parent":"1445bf0e3d13","children":[{"parent":"d7f62e0c4636","children":[],"id":"27bd6a411b10d117","title":"扰动算法 高低16位异或 充分哈希，与上符号位0 得到正数"},{"parent":"d7f62e0c4636","children":[],"id":"b2f420a89de07f12","title":"根据哈希值使用哈希算法 hash &amp; length-1 得到索引"},{"parent":"d7f62e0c4636","children":[],"id":"08ded9c1cc15211f","title":"寻找比较时，先比较哈希值再比较key"},{"parent":"d7f62e0c4636","children":[{"parent":"ad9c1fc31e23798d","children":[{"parent":"53871ddf9200f0bc","children":[],"id":"47e927caa4cc2a4d","title":"遍历链表寻找"},{"parent":"53871ddf9200f0bc","children":[],"id":"f8b8008f342ef65d","title":"treebin节点 遍历红黑树寻找"},{"parent":"53871ddf9200f0bc","children":[],"id":"94bf880f12759dcc","title":"转发节点去新哈希表中寻找"},{"parent":"53871ddf9200f0bc","children":[],"id":"4a98d05ba900c720","title":"占位节点直接返回"}],"id":"53871ddf9200f0bc","title":"不同情况"}],"id":"ad9c1fc31e23798d","title":"根据索引首节点情况进行处理"}],"collapsed":true,"id":"d7f62e0c4636","title":"get : 无锁，使用volatile保证可见性"},{"parent":"1445bf0e3d13","children":[{"parent":"013ddc8f9e28","children":[],"id":"f43316d97b693500","title":"如果哈希表为空，CAS保证一个线程初始化"},{"parent":"013ddc8f9e28","children":[{"parent":"fb29183ab9619837","children":[],"id":"a12ac594e7ea218c","title":"首节点为空，CAS添加节点"},{"parent":"fb29183ab9619837","children":[],"id":"41e8233f2fd44a62","title":"首节点为转发节点，去帮助扩容"},{"parent":"fb29183ab9619837","children":[{"parent":"81954c21ba8bd81d","children":[],"id":"d14f33d0d36b10a7","title":"遍历链表 寻找 覆盖/尾插添加"},{"parent":"81954c21ba8bd81d","children":[],"id":"e4523ddee71cb780","title":"遍历树 寻找 覆盖/添加"}],"id":"81954c21ba8bd81d","title":"其他情况锁住首节点"}],"id":"fb29183ab9619837","title":"扰动算法，哈希值通过哈希得到索引，根据索引首节点情况进行处理"},{"parent":"013ddc8f9e28","children":[],"id":"136f89a1f21d7a43","title":"如果是添加会增加数量统计并检查扩容"}],"collapsed":true,"id":"013ddc8f9e28","title":"put: 先用乐观锁初始化数组/构建首节点，在某个链表上添加/替换时采用synchronized锁住首节点"},{"parent":"1445bf0e3d13","children":[{"parent":"9f307e7be376d911","children":[],"id":"e50e5262725ed981","title":"添加put和批量添加putAll，帮助扩容都会走到扩容核心逻辑"},{"parent":"9f307e7be376d911","image":{"w":119,"h":39,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-6513c1d78682296b31920ba9?e=1695797223&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Y6rR2TWM1EvLDRUwtX_X-BWJoiY=","direction":"up"},"children":[],"id":"e9df02a5d02e6a75","title":"使用新旧两个哈希表，扩容时计算每个线程负责迁移的索引区间，进行循环迁移直到完成（多线程进行迁移）"},{"parent":"9f307e7be376d911","image":{"w":81,"h":41,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-6513c1e1533ea47a465b4e88?e=1695797233&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:B0W-Hl1WdSH5u-Lm2WsO-DloAC4=","direction":"up"},"children":[],"id":"74744c6b249400af","title":"迁移每个索引时会将节点迁移到index&nbsp;或&nbsp;index&nbsp;+&nbsp;旧哈希表长度题"},{"parent":"9f307e7be376d911","image":{"w":64,"h":37,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-6513c1ee1a4a06156d6e4ccd?e=1695797246&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:6FVvla8QpC1izFWTQqvIfHO15bM=","direction":"up"},"children":[],"id":"c4b1c7d0096431cd","title":"迁移完成对应索引在旧哈希表位置设置转发节点，遇到get通过转发节点来新哈希表查找，遇到put来帮助扩容"}],"id":"9f307e7be376d911","title":"扩容"}],"collapsed":false,"id":"1445bf0e3d13","title":"采用node数组 + node链表/红黑树"}],"id":"da8f3e1c78ce","title":"JDK8&nbsp;"}],"id":"5d990abd7dfbc6d8","title":"实现"},{"parent":"b48bd81777b4","children":[{"parent":"e20d5e049789fc44","children":[],"id":"9a04fd0871df1deb","title":"并不是绝对线程安全，只是每个方法提供的相对线程安全，在外层使用时需要计算使用computer方法"},{"parent":"e20d5e049789fc44","children":[],"id":"7649bc4b5ca0dc4d","title":"迭代器弱一致性，获取时通过哈希表创建新的迭代器对象"}],"id":"e20d5e049789fc44","title":"使用"}],"collapsed":true,"id":"b48bd81777b4","title":"ConcurrentHashMap"}],"collapsed":true,"id":"f9d0d3b631c2","title":"并发集合"},{"parent":"root","lineStyle":{"lineType":"curve","underLine":true,"randomLineColor":"#F88A35","lineWidth":3},"children":[{"parent":"7ed799178230c6f4","children":[{"parent":"15236572184a3984","children":[],"id":"21ba2fceb3d0ed63","title":"存储线程本地变量，隔离线程间的数据"}],"id":"15236572184a3984","title":"概念"},{"parent":"7ed799178230c6f4","children":[{"parent":"cd58c59b74baef22","children":[],"id":"1f66b63811a21226","title":"存储会话信息"},{"parent":"cd58c59b74baef22","children":[],"id":"82b1d5663de21ba3","title":"存储线程上下文信息"}],"id":"cd58c59b74baef22","title":"使用场景"},{"parent":"7ed799178230c6f4","image":{"w":39,"h":63,"url":"https://cdn.processon.com/5e1d083ae4b0c3908f85f937-6512a9a49b6a0359c948ce32?e=1695725492&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:zT9uLWtSF03QdbpMFVhnjLMwpB8=","direction":"up"},"children":[{"parent":"62df68bbd6ece843","children":[],"id":"7efeeafdabe0c2a5","title":"Thread 存储 ThreadLocalMap"},{"parent":"62df68bbd6ece843","children":[],"id":"34c894e11d5b25f4","title":"ThreadLocalMap 是 ThreadLocal 内部类，使用开放定址法解决哈希冲突的哈希表，节点entry（K：ThreadLocal，V：value）内部类继承弱引用，将thread local设置成弱引用"},{"parent":"62df68bbd6ece843","children":[],"id":"5fc7ccbd7168a689","title":"在set、get、remove等常用方法都会清理key为空的节点"}],"id":"62df68bbd6ece843","title":"实现原理"},{"parent":"7ed799178230c6f4","children":[{"parent":"b6c266ddd7590efb","children":[],"id":"5622d5ea70ccdcb3","title":"当thread local不再使用时，节点entry中的key为空，如果value也不再使用会发生内存泄漏"},{"parent":"b6c266ddd7590efb","children":[],"id":"47216d3573f565ba","title":"使用完删除，其他方法也会清理key为空的节点"}],"id":"b6c266ddd7590efb","title":"内存泄漏"},{"parent":"7ed799178230c6f4","children":[{"parent":"df752d05f3def80d","children":[{"parent":"3732d802a7b004b2","children":[],"id":"8e2ae1c506275b1f","title":"如果key为强引用，当thread local不再使用时，也会发生内存泄漏"},{"parent":"3732d802a7b004b2","children":[],"id":"a9d03d81d7989480","title":"虽然设置成弱引用后也可能发生内存泄漏，但可以检查这种key为空的节点并清理，避免内存泄漏"}],"id":"3732d802a7b004b2","title":"为什么把key设置成弱引用？"},{"parent":"df752d05f3def80d","children":[{"parent":"c936094f7d1bc801","children":[],"id":"1a3b2eb638080ce7","title":"value 设置成弱引用，外层不再使用，gc会清理掉"}],"id":"c936094f7d1bc801","title":"为什么不把value也设置成弱引用"}],"id":"df752d05f3def80d","title":"设计思想"}],"collapsed":true,"id":"7ed799178230c6f4","title":"ThreadLocal"}],"root":true,"theme":"delicate_caihong","showWatermark":false,"id":"root","title":"并发编程","lines":{"d8e25093aa378edf":{"startAngle":353.5745604704576,"start":{"x":"1.0","y":"0.3","index":2},"endAngle":7.208500268741449,"label":"创建monitor&nbsp; CAS替换mark word","pts":[{"x":297.15625,"y":-33.859375},{"x":199.15625,"y":26.5625}],"points":[{"x":11544.727661132812,"y":10603.172302246094},{"x":11433.727661132812,"y":10707.809387207031}],"realEnd":{"x":11269.571411132812,"y":10687.04688720703},"styles":{"color":"#ffffff","lineColor":"rgb(113, 203, 45)","lineWidth":2},"from":"97e0c5baf9d87139","end":{"x":"1.0","y":"0.7","index":3},"id":"d8e25093aa378edf","realStart":{"x":11295.571411132812,"y":10631.231677246094},"to":"6f37e38709537103"},"384993bb323678ec":{"startAngle":358.6763958676738,"start":{"x":"1.0","y":"0.4","index":2},"endAngle":344.1960200997302,"label":"锁粒度大","pts":[{"x":118.34375,"y":-2.734375},{"x":85.34375,"y":-24.15625}],"points":[{"x":11057,"y":10147},{"x":10968,"y":10081}],"realEnd":{"x":10912.65625,"y":10096.15625},"styles":{"color":"#ffffff","lineColor":"rgb(113, 203, 45)","lineWidth":2},"from":"d582e4fdcae39d67","end":{"x":"1.0","y":"0.2","index":2},"id":"384993bb323678ec","realStart":{"x":11024.65625,"y":10146.734375},"to":"fee1d1454aadf369"}},"version":2156,"structure":"mind_free"}},"meta":{"exportTime":"2024-03-04 21:36:17","member":"","diagramInfo":{"creator":"","created":"2024-03-04 21:35:26","modified":"2024-03-04 21:36:15","title":"并发编程","category":"mind_free"},"id":"65e5ce1b778cc210345d8d4b","type":"ProcessOn Schema File","version":"1.0"}}