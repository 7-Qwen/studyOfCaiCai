{"diagram":{"elements":{"leftChildren":[],"note":"","watermark":"","children":[{"parent":"root","lineStyle":{"randomLineColor":"#FD5155"},"children":[{"parent":"eb54e0c811a5bc98","children":[{"parent":"1e29c57332cf892d","children":[],"id":"d215f687341abef1","title":"可以自定义名称，见名知意"},{"parent":"1e29c57332cf892d","children":[],"id":"77a2cc797cde97b1","title":"获取对象时，可以使用单例、享元等思想进行复用"},{"parent":"1e29c57332cf892d","children":[],"id":"03678bdbe9d41dac","title":"可以返回原类型的子类"},{"parent":"1e29c57332cf892d","children":[],"id":"09b8f9975ef31d32","title":"返回对象可以随着入参发生改变"},{"parent":"1e29c57332cf892d","children":[],"id":"4b07966e4b762c83","title":"返回对象的类可以在编写静态工厂时不存在"}],"collapsed":true,"id":"1e29c57332cf892d","title":"静态工厂替代构造器"},{"parent":"eb54e0c811a5bc98","children":[{"parent":"5f648bd8082fdce2","children":[],"id":"8777790da881e5c0","title":"Builder 建造者模式"},{"parent":"5f648bd8082fdce2","children":[],"id":"adf139cee58e05cf","title":"方便阅读"},{"parent":"5f648bd8082fdce2","children":[],"id":"4067b32672a5a21e","title":"防止构造时逃逸"},{"parent":"5f648bd8082fdce2","children":[],"id":"faa56b714af1f23b","title":"Builder类的开销"}],"collapsed":true,"id":"5f648bd8082fdce2","title":"构造器参数太多考虑建造者模式"},{"parent":"eb54e0c811a5bc98","children":[{"parent":"fd0e9d8e79a8472d","children":[{"parent":"b4dd3a1fc1efb06d","children":[],"id":"6952d961e2c8df95","title":"通过字段获取单例"},{"parent":"b4dd3a1fc1efb06d","children":[],"id":"1ec746f854486dd7","title":"通过静态工厂方法获取单例"},{"parent":"b4dd3a1fc1efb06d","children":[],"id":"a3d5a273a90bfefa","title":"私有构造"},{"parent":"b4dd3a1fc1efb06d","children":[],"id":"9226912041348bae","title":"会被反射破坏单例"}],"id":"b4dd3a1fc1efb06d","title":"懒汉"},{"parent":"fd0e9d8e79a8472d","children":[{"parent":"65710e6e10eb2cde","children":[],"id":"dafa07c1cf683493","title":"防止反射调用构造"},{"parent":"65710e6e10eb2cde","children":[],"id":"99abd9030f9594ed","title":"反射调用构造前判断枚举则抛出异常"}],"id":"65710e6e10eb2cde","title":"枚举单元素"}],"collapsed":true,"id":"fd0e9d8e79a8472d","title":"私有构造或枚举强化单例"},{"parent":"eb54e0c811a5bc98","children":[{"parent":"3ca3979b2a8351ce","children":[],"id":"8998832722218588","title":"要使用多种工具时，通过构造器注入工具"},{"parent":"3ca3979b2a8351ce","children":[],"id":"22c484c037c1c728","title":"灵活，项目大时依赖多，使用DI框架解决 spring的IOC"}],"collapsed":true,"id":"3ca3979b2a8351ce","title":"考虑构造器的依赖注入"},{"parent":"eb54e0c811a5bc98","children":[{"parent":"c9681589a3ccaa24","children":[],"id":"412458ab6d0ac2d8","title":"自动拆装箱"},{"parent":"c9681589a3ccaa24","children":[],"id":"13a457edcf05f9b1","title":"字符串"}],"collapsed":true,"id":"c9681589a3ccaa24","title":"避免创建不必要对象"},{"parent":"eb54e0c811a5bc98","children":[{"parent":"ece084e9d39914a0","children":[],"id":"52f4797c6e7c0a2a","title":"不使用对象时，需要清楚引用否则会内存泄漏"}],"collapsed":true,"id":"ece084e9d39914a0","title":"消除过期对象引用"},{"parent":"eb54e0c811a5bc98","children":[{"parent":"b16941fde0b6a4ca","children":[],"id":"3e89cbbb81836d25","title":"finalize 不可达对象才调用，由守护线程调用，无法预估执行时机"},{"parent":"b16941fde0b6a4ca","children":[],"id":"acef439e5b472cb9","title":"要关闭资源使用finally"}],"collapsed":true,"id":"b16941fde0b6a4ca","title":"不使用finalize"},{"parent":"eb54e0c811a5bc98","children":[{"parent":"80f7e415e34a82da","children":[],"id":"860f2ad2dd7c8680","title":"twr自动关闭"}],"collapsed":true,"id":"80f7e415e34a82da","title":"twr优于try-with-resource"}],"collapsed":true,"id":"eb54e0c811a5bc98","title":"创建和销毁对象"},{"parent":"root","lineStyle":{"randomLineColor":"#FD5155"},"children":[{"parent":"463cb9643605305f","children":[{"parent":"6013a1d3efc0f67d","children":[],"id":"d57e6eb8c60c2a37","title":"equals表示逻辑相等，当需要判断对象逻辑相等时重写equals方法"},{"parent":"6013a1d3efc0f67d","children":[],"id":"3bfb9f2d9ff87436","title":"重写equals通用方案一般为先判断对象引用是否相等，再判断对象是否为同类型，为同类型再根据关键字段进行比较"},{"parent":"6013a1d3efc0f67d","children":[],"id":"4088ded70fff7ebe","title":"重写equals需要根据根据逻辑相等的字段重写hashCode，否则在使用哈希表实现的数据结构时会出现严重问题"},{"parent":"6013a1d3efc0f67d","children":[],"id":"c0c60bb61e82921e","title":"使用哈希表时Key最好为不可变对象，或让对象的hashCode不会随着字段值改变，否则会出现严重问题"}],"id":"6013a1d3efc0f67d","title":"重写equals的通用规定"},{"parent":"463cb9643605305f","children":[{"parent":"b7abf81e8ef06ed4","children":[],"id":"fc93269dbd761e60","title":"始终要重写toString，输出关键字段信息，方便阅读、调试"}],"id":"b7abf81e8ef06ed4","title":"始终要重写toString"},{"parent":"463cb9643605305f","children":[{"parent":"6d630d6e78d7f05f","children":[],"id":"3f2f292449934246","title":"谨慎重写clone，clone用于对象的克隆"},{"parent":"6d630d6e78d7f05f","children":[{"parent":"c93b2777660287b8","children":[],"id":"76ea4fdf8ce8d6b6","title":"重写clone需要实现Cloneable空接口，否则会抛出&nbsp;`CloneNotSupportedException`&nbsp;异常"},{"parent":"c93b2777660287b8","children":[],"id":"cc8d974c40da9a99","title":"调用&nbsp;`super.clone`&nbsp;实现的是浅拷贝，如果要实现深拷贝，字段中的类也需要重写clone方法"},{"parent":"c93b2777660287b8","children":[],"id":"718773d9b95c6357","title":"如果字段是final的则无法实现深拷贝"},{"parent":"c93b2777660287b8","children":[],"id":"b98e05bcaf4525c6","title":"实体类携带克隆方法，耦合性较高，违法单一职责"}],"id":"c93b2777660287b8","title":"在设计上并不太好还存在一些缺点"}],"id":"6d630d6e78d7f05f","title":"谨慎重写clone"},{"parent":"463cb9643605305f","children":[{"parent":"6ff28a271206a7be","children":[],"id":"ab6e6096d198ec1a","title":"对于需要排序的对象，考虑实现Comparable或Comparator接口"},{"parent":"6ff28a271206a7be","children":[{"parent":"899372174e549d07","children":[],"id":"f64426b130c10e36","title":"Comparator&nbsp;外部比较器一般优先&nbsp;Comparable&nbsp;内部比较器"},{"parent":"899372174e549d07","children":[],"id":"67b37a9ff5bcecfd","title":"使用某些需要排序的容器时（红黑树&nbsp;TreeMap），如果不实现比较器在转换时会发生异常"},{"parent":"899372174e549d07","children":[],"id":"51b59f78a73bd669","title":"实现排序时，根据多个关键字段重要程度进行排序，基本类型可以使用包装类的compare方法"},{"parent":"899372174e549d07","children":[],"id":"107d64deb0e582ae","title":"外部排序器提供lambda表达式构造Comparator外部比较器"}],"id":"899372174e549d07","title":"实现注意"}],"id":"6ff28a271206a7be","title":"考虑实现Comparable接口"}],"collapsed":true,"id":"463cb9643605305f","title":"对于所有对象都通用的方法"},{"parent":"root","lineStyle":{"randomLineColor":"#02ACF4"},"children":[{"parent":"6bc0a308dc55a0ce","children":[{"parent":"88241a78fd79b8f2","children":[{"parent":"543ba9fde0d5793d","children":[{"parent":"867694ef938c3b59","children":[],"id":"76969da235b3d488","title":"解耦"},{"parent":"867694ef938c3b59","children":[],"id":"bfd90e5a9e69c810","title":"独立"},{"parent":"867694ef938c3b59","children":[],"id":"fdc0228aae3b4ccb","title":"可重用"}],"collapsed":true,"id":"867694ef938c3b59","title":"封装"},{"parent":"543ba9fde0d5793d","children":[{"parent":"f03e6f0bf8974da1","children":[],"id":"c33d11f9ed715f54","title":"可访问性最小化"},{"parent":"f03e6f0bf8974da1","children":[],"id":"31cc5f5e2c715726","title":"字段私有"},{"parent":"f03e6f0bf8974da1","children":[],"id":"d734a07a7a1d0b0a","title":"常量最好是不可变对象"}],"id":"f03e6f0bf8974da1","title":"设计"}],"collapsed":false,"id":"543ba9fde0d5793d","title":"让类和字段的可访问性最小化"},{"parent":"88241a78fd79b8f2","children":[{"parent":"e3512302d99a9b7d","children":[],"id":"ff6ca2e15f3145ab","title":"使用方法访问字段"}],"collapsed":false,"id":"e3512302d99a9b7d","title":"要使用方法访问类的字段"},{"parent":"88241a78fd79b8f2","children":[{"parent":"eb927e37c6a71f43","children":[{"parent":"8746ff4bf2404ac0","children":[],"id":"b78fc620906d1ee4","title":"私有、final 修饰所有字段"},{"parent":"8746ff4bf2404ac0","children":[],"id":"add7be4c1e5960b9","title":"不提供修改对象字段的方法"},{"parent":"8746ff4bf2404ac0","children":[],"id":"f4d31d7e70999a97","title":"保证类不被扩展 final class"},{"parent":"8746ff4bf2404ac0","children":[],"id":"a5d56724ddf32ad0","title":"如果字段为对象，确保字段不被泄漏"}],"collapsed":true,"id":"8746ff4bf2404ac0","title":"设计上常用不可变对象"},{"parent":"eb927e37c6a71f43","children":[{"parent":"0407783d53f0d764","children":[],"id":"0bf684f6da41dc95","title":"简单易实现"},{"parent":"0407783d53f0d764","children":[],"id":"7c36ab5e61d00169","title":"线程安全"},{"parent":"0407783d53f0d764","children":[],"id":"dfeba3a6f5431cdf","title":"原子性"},{"parent":"0407783d53f0d764","children":[],"id":"1c915948278e1917","title":"充当哈希表的key"}],"collapsed":true,"id":"0407783d53f0d764","title":"不可变对象优点"},{"parent":"eb927e37c6a71f43","children":[{"parent":"e89cb4a71aaf4302","children":[],"id":"a58ec894bbd6882c","title":"性能不好、每个值都需要一个对象"},{"parent":"e89cb4a71aaf4302","children":[],"id":"79ae2d657642de74","title":"可以使用享元、缓存常用不可变对象"}],"id":"e89cb4a71aaf4302","title":"缺点"}],"collapsed":false,"id":"eb927e37c6a71f43","title":"可变性最小化"},{"parent":"88241a78fd79b8f2","children":[{"parent":"54d1a87b2c6551f9","children":[],"id":"6d85a91f248c5b3a","title":"继承会打破封装，子类依赖父类实现细节时，如果不熟悉实现原理可能踩坑"},{"parent":"54d1a87b2c6551f9","children":[],"id":"1b0f39f33f8bfa58","title":"依赖对象最好使用复合更能保留封装特性，除非A is a B"}],"id":"54d1a87b2c6551f9","title":"复合优于继承"},{"parent":"88241a78fd79b8f2","children":[{"parent":"50b73eec576e0c1c","children":[],"id":"12f1a0848195a551","title":"使用继承需要提供文档说明，且不能在构造中调用可重写方法"},{"parent":"50b73eec576e0c1c","children":[],"id":"fcb88e3ca9e74f8b","title":"提供文档说明的成本大，一般只做模板方法的抽象类中做文档说明"}],"id":"50b73eec576e0c1c","title":"要么设计继承并提供文档说明，要么禁止继承"}],"collapsed":true,"id":"88241a78fd79b8f2","title":"类"},{"parent":"6bc0a308dc55a0ce","children":[{"parent":"92edec31d91e5090","children":[{"parent":"dc92514825ff3f81","children":[],"id":"22b7e737104fe00f","title":"接口定义抽象、抽象类实现接口方法的模板，充当中间层，核心方法留给子类实现"},{"parent":"dc92514825ff3f81","children":[],"id":"0e81f928a49e793e","title":"接口定义单一功能抽象，留给实现类扩展增强功能"}],"id":"dc92514825ff3f81","title":"接口优于抽象类"},{"parent":"92edec31d91e5090","children":[{"parent":"dcaf2beb598d6410","children":[],"id":"f90362003a277582","title":"接口提供默认方法，也可以定义实现，并且实现类可以选择性扩展"}],"id":"dcaf2beb598d6410","title":"为后代设计接口"},{"parent":"92edec31d91e5090","children":[{"parent":"e9d939e2e868e082","children":[],"id":"242456ed9613906c","title":"接口只用于定义类型，提供抽象、默认方法，不要用常量接口"}],"id":"e9d939e2e868e082","title":"接口只用于定义类型"},{"parent":"92edec31d91e5090","children":[{"parent":"c3011f4ceac05e76","children":[],"id":"a9251b1b9809e092","title":"使用多层继承代替冗余、复杂、违反单一职责的标签类"}],"id":"c3011f4ceac05e76","title":"类层次优于标签类"}],"collapsed":true,"id":"92edec31d91e5090","title":"接口"},{"parent":"6bc0a308dc55a0ce","children":[{"parent":"1170a51c664ca941","children":[{"parent":"4f49e78c7fb23b8a","children":[{"parent":"f90c6cd3092347ec","children":[],"id":"94f7e31545f28bb7","title":"静态内部类不依赖外部类，不使用外部类字段时优先考虑"},{"parent":"f90c6cd3092347ec","children":[],"id":"fa883a250948ab4a","title":"非静态内部类依赖外部类，使用外部类字段时才选择，并且注意内存泄漏"}],"id":"f90c6cd3092347ec","title":"类中"},{"parent":"4f49e78c7fb23b8a","children":[{"parent":"12b60839686a4472","children":[],"id":"47febaec737ead53","title":"使用多次选择局部内部类"},{"parent":"12b60839686a4472","children":[],"id":"6f6c1f8c382d4f14","title":"使用一次选择匿名内部类 lambda"}],"id":"12b60839686a4472","title":"方法中"}],"id":"4f49e78c7fb23b8a","title":"静态内部类优于非静态内部类"},{"parent":"1170a51c664ca941","children":[{"parent":"a0afd34925415b6a","children":[],"id":"3ede3c7adbaadac8","title":"单个顶级类为源文件，需要其他类则使用静态内部类"}],"id":"a0afd34925415b6a","title":"限制源文件为单个顶级类"}],"collapsed":false,"id":"1170a51c664ca941","title":"内部类"}],"collapsed":true,"id":"6bc0a308dc55a0ce","title":"类和接口"},{"parent":"root","lineStyle":{"lineType":"curve","underLine":true,"randomLineColor":"#FA5465","lineWidth":3},"children":[{"parent":"aaa1d176b18ac8ec","lineStyle":{"randomLineColor":"#3D5EC2"},"children":[{"parent":"e924847c70712db7","children":[],"id":"74c8744c190302da","title":"泛型能够指定对象类型，编译期间类型擦除并完成强制转换"},{"parent":"e924847c70712db7","children":[],"id":"04528d40a4513e39","title":"使用原生态类型会丢失泛型的所有优点：安全、灵活"},{"parent":"e924847c70712db7","children":[{"parent":"378cd92d9a8c0f12","children":[],"id":"dd386d2971bb29f6","title":"兼容历史版本"},{"parent":"378cd92d9a8c0f12","children":[],"id":"ece3ba2e21d9e5ed","title":"使用Class对象"},{"parent":"378cd92d9a8c0f12","children":[],"id":"0efd9beaec52b83e","title":"使用interface"}],"id":"378cd92d9a8c0f12","title":"原生态类型使用场景"}],"id":"e924847c70712db7","title":"不要使用原生态类型"},{"parent":"aaa1d176b18ac8ec","lineStyle":{"randomLineColor":"#FD5155"},"children":[{"parent":"a2c981176bf147bb","children":[],"id":"64c57d29ffacf21d","title":"不合理使用泛型会出现警告，不影响编译，但可能出现强转失败"},{"parent":"a2c981176bf147bb","children":[],"id":"c329ee6e08206f3c","title":"使用注解@SuppressWarnings抑制警告，并留下注释，作用域越小越好"}],"id":"a2c981176bf147bb","title":"消除非受检警告"},{"parent":"aaa1d176b18ac8ec","lineStyle":{"randomLineColor":"#7549C5"},"children":[{"parent":"33a0f6e284a5c782","children":[],"id":"3c80cca24cc2ad15","title":"数组只提供运行时安全，并不提供编译时安全，并且不能使用泛型数组（无限制通配符除外）"},{"parent":"33a0f6e284a5c782","children":[],"id":"945dc2d7ebf295bc","title":"当列表与数组同时使用时，优先使用列表，它能得到使用泛型的好处"}],"id":"33a0f6e284a5c782","title":"列表优于数组"},{"parent":"aaa1d176b18ac8ec","lineStyle":{"randomLineColor":"#BE49C4"},"children":[{"parent":"102336c70f67ee27","children":[],"id":"9b7e9e4408595894","title":"部分情况下，必须使用数组，此时为了通用性，也会配合泛型使用，但不是使用泛型数组"},{"parent":"102336c70f67ee27","children":[{"parent":"32c1eee5e0336702","children":[{"parent":"b4cc12e82172cd1b","code":{"curLanguage":"Java","lineNumbers":true,"width":560,"language":"clike","theme":"base16-light","id":"5aee0d1efe1d7567","text":"public class Stack<E> {\n    private E[] elements;\n    @SuppressWarnings(\"unchecked\")\n    public Stack() {\n        elements = (E[]) new Object[16];\n    }\n}","lineWrapping":true,"height":180},"children":[],"style":{"font-size":12},"id":"4868e461143ad51b","title":"代码案例"}],"collapsed":true,"id":"b4cc12e82172cd1b","title":"定义泛型数组，实例化时使用Object数组进行强转"},{"parent":"32c1eee5e0336702","children":[{"parent":"0a0af5a95169cef1","code":{"curLanguage":"Java","lineNumbers":true,"width":560,"language":"clike","theme":"base16-light","id":"c4798b7d20645659","text":"transient Object[] elementData; \n\n public ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } \n }","lineWrapping":true,"height":180},"children":[],"id":"40a347554c51eaf0","title":"构造"},{"parent":"0a0af5a95169cef1","code":{"curLanguage":"Java","lineNumbers":true,"width":560,"language":"clike","theme":"base16-light","id":"0660a1c5ce131482","text":"public E get(int index) {\n    rangeCheck(index);\n    return elementData(index);\n}\n\n@SuppressWarnings(\"unchecked\")\nE elementData(int index) {\n    return (E) elementData[index];\n}","lineWrapping":true,"height":209},"children":[],"id":"9c0e355dae674ed1","title":"读数据"}],"collapsed":true,"id":"0a0af5a95169cef1","title":"使用Object数组，读取数据时进行强转&nbsp; ArrayList 就是使用这种方案"}],"id":"32c1eee5e0336702","title":"数组 + 泛型 实现方案"}],"id":"102336c70f67ee27","title":"优先考虑泛型"},{"parent":"aaa1d176b18ac8ec","lineStyle":{"randomLineColor":"#F88A35"},"children":[{"parent":"2de352756b741460","children":[],"id":"26b4d22f938ae6df","title":"使用泛型方法：安全、通用、不需要强转"},{"parent":"2de352756b741460","children":[{"parent":"466087fc2dacc695","code":{"curLanguage":"Java","lineNumbers":true,"width":560,"language":"clike","theme":"base16-light","id":"f9a7b6a9740d8c13","text":"public static <T extends Strategy> T getStrategyByKey(String key) {\n    Strategy strategy = strategyFactory.get(key);\n    if (Objects.isNull(strategy)) {\n        return null;\n    }\n    //确保工厂中的实现类都实现策略，否则强转会抛出异常\n    return (T) strategy;\n}","lineWrapping":true,"height":194},"children":[],"id":"9d4483c127a43a1e","title":"策略工厂的泛型方法，使用注解避免抑制警告，同时需要strategyFactory中value对象都实现策略"}],"collapsed":true,"id":"466087fc2dacc695","title":"可以搭配有限通配符使用、方法内需要强转，需要抑制警告"}],"id":"2de352756b741460","title":"优先考虑泛型方法"},{"parent":"aaa1d176b18ac8ec","lineStyle":{"randomLineColor":"#FCB52A"},"children":[{"parent":"4acd58244166c218","children":[],"id":"f89b70f0383342e1","title":"上限通配符 &lt;? extends T&gt; 确定上限为T，不确定下限，只允许读不允许写"},{"parent":"4acd58244166c218","children":[],"id":"cf8e0820a00b7a72","title":"下限通配符 &lt;? super T&gt; 确定上限为Object，不确定下限，读时只能读到Object，允许写"},{"parent":"4acd58244166c218","children":[],"id":"aaca18d5f011f192","title":"遵循PECS原则，生产（读：提供数据给外界）使用extends，消费（写：消费外界传入数据）使用super"}],"id":"4acd58244166c218","title":"利用有限通配符提示API灵活性"},{"parent":"aaa1d176b18ac8ec","lineStyle":{"randomLineColor":"#0D7C82"},"children":[{"parent":"ab4b6c754da6f240","children":[],"id":"00978a530baf3db3","title":"可变参数实际上是数组"},{"parent":"ab4b6c754da6f240","children":[],"id":"018dde8d5def2ace","title":"JDK允许可变参数与泛型同时使用，但确保类安全需要使用注解@SafeVarargs"}],"id":"ab4b6c754da6f240","title":"泛型和可变参数谨慎同时使用"},{"parent":"aaa1d176b18ac8ec","lineStyle":{"randomLineColor":"#DD489D"},"children":[{"parent":"70803a07cb0fa01c","children":[],"id":"7db35a97a8bef8fa","title":"需要存储多个不同类型对象时，考虑使用泛型Class&lt;?&gt;作为Key，存储对象作为Value"}],"id":"70803a07cb0fa01c","title":"优先考虑类型安全异构容器"}],"collapsed":true,"id":"aaa1d176b18ac8ec","_id":"root","title":"泛型"},{"parent":"root","lineStyle":{"lineType":"curve","underLine":true,"randomLineColor":"#80BA4C","lineWidth":3},"children":[{"parent":"1e149a12ab0c836e","lineStyle":{"randomLineColor":"#3D5EC2"},"children":[{"parent":"7a7f4d6154904665","children":[{"parent":"88fad75adb9036a8","children":[],"id":"ae47fc0a8c2b7b61","title":"枚举类继承自抽象类enum，常用于定义常量、可由多个字段组成，提供遍历枚举的方法values"},{"parent":"88fad75adb9036a8","children":[],"id":"f826f899caf0eeb7","title":"枚举可以用来代替需要关联的常量，提升类型安全、可读性、扩展性"}],"id":"88fad75adb9036a8","title":"使用枚举代替部分常量"},{"parent":"7a7f4d6154904665","children":[{"parent":"0a7ccf8cd1366943","children":[],"id":"f38c8192c800ad86","title":"ordinal为枚举类中枚举顺序，如果改变位置值会发生变动，如果依赖顺序性则使用字段表示"}],"id":"0a7ccf8cd1366943","title":"使用字段代替ordinal"},{"parent":"7a7f4d6154904665","children":[{"parent":"9d99fb3c6a9f5ead","children":[],"id":"1a41f35bb92880cc","title":"EnumSet 使用位运算用少量空间高效存储同一集合的枚举常量"}],"id":"9d99fb3c6a9f5ead","title":"善用EnumSet"},{"parent":"7a7f4d6154904665","children":[{"parent":"88da772608788974","children":[],"id":"65cb32264aeae89f","title":"EnumMap 使用ordinal做索引，高效、线性、空间紧凑的根据枚举常量类型进行分组"}],"id":"88da772608788974","title":"善用EnumMap"},{"parent":"7a7f4d6154904665","children":[{"parent":"c5ff25c26ed5b66b","children":[],"id":"e6b2c04560596bdc","title":"如果想像新增类那样扩展枚举，可以提供定义接口，新增枚举类扩展接口来实现"}],"id":"c5ff25c26ed5b66b","title":"使用接口扩展枚举"}],"id":"7a7f4d6154904665","title":"枚举"},{"parent":"1e149a12ab0c836e","lineStyle":{"randomLineColor":"#0F80C4"},"children":[{"parent":"fb6efe4ca93b88bf","children":[{"parent":"19af8bdcc5e64c99","children":[],"id":"523fb3b841087423","title":"命名模式：约定规则，如果忘记、不遵守规则则会出现问题"},{"parent":"19af8bdcc5e64c99","children":[],"id":"def3abf870ca9cbe","title":"使用标记注解标记代码，在处理时判断是否标记，标记则特殊处理"}],"id":"19af8bdcc5e64c99","title":"标记注解优于命名模式"},{"parent":"fb6efe4ca93b88bf","children":[{"parent":"7392d617187358f7","children":[],"id":"c8653dc7a2fcc88b","title":"覆写时使用override注解，如果不小心写成重载，那么编译器就会提前暴露问题"}],"id":"7392d617187358f7","title":"坚持使用Override注解"},{"parent":"fb6efe4ca93b88bf","children":[{"parent":"840fde666f4a60e0","children":[],"id":"b7f645e76efaa8e8","title":"标记接口用于定义类型，使用标记接口可以在编译器类型检查，但只能用于类或接口；如果用于方法、字段则要使用标记注解"}],"id":"840fde666f4a60e0","title":"善用标记接口"}],"id":"fb6efe4ca93b88bf","title":"注解"}],"collapsed":true,"id":"1e149a12ab0c836e","_id":"root","title":"枚举与注解"},{"parent":"root","lineStyle":{"lineType":"curve","underLine":true,"randomLineColor":"#BE49C4","lineWidth":3},"children":[{"parent":"56d29cb10a9cd035","lineStyle":{"randomLineColor":"#02ACF4"},"children":[{"parent":"bad2cf03b637ca9f","children":[],"id":"6bf1906cff6d815d","title":"函数接口只存在一个抽象方法，并用注解@FunctionalInterface标识，可以使用Lambda表达式实现"},{"parent":"bad2cf03b637ca9f","children":[],"id":"d58b07967fd6927f","title":"简单易懂的函数接口使用Lambda实现简洁，优于匿名内部类"}],"id":"bad2cf03b637ca9f","title":"Lambda优于匿名内部类"},{"parent":"56d29cb10a9cd035","lineStyle":{"randomLineColor":"#0FBAB0"},"children":[{"parent":"6c7a16aa0ec803c2","children":[],"id":"27966e6ac7c20f42","title":"方法引用比Lambda更简洁，但某些情况下太简介会降低可读性"},{"parent":"6c7a16aa0ec803c2","children":[],"id":"556f21ffe96c2f49","title":"Lambda与方法引用都简洁，哪种方式更易提示代码可读性选择哪种"}],"id":"6c7a16aa0ec803c2","title":"善用方法引用"},{"parent":"56d29cb10a9cd035","lineStyle":{"randomLineColor":"#DD489D"},"children":[{"parent":"ef1a78eca8a8cb8b","children":[],"id":"104d70f542b5b2d4","title":"java.util.function提供标准函数接口，当设计组件时优先选择标准函数接口，不满足需求再自定义"}],"id":"ef1a78eca8a8cb8b","title":"坚持使用标准函数接口"},{"parent":"56d29cb10a9cd035","lineStyle":{"randomLineColor":"#FA5465"},"children":[{"parent":"85af86a0520a7f75","children":[],"id":"e72c0c22f9202c01","title":"Stream流式处理能够给编写代码带来极大简便"},{"parent":"85af86a0520a7f75","children":[],"id":"f97d1c47f2b81092","title":"当业务代码流程复杂，滥用Stream会降低代码可读性、维护性；最好结合Stream和迭代的方式写出可读性、可维护性高的代码"},{"parent":"85af86a0520a7f75","children":[],"id":"f4f47ad50a821470","title":"避免使用Stream处理char类型，会转化为Int类型处理"}],"id":"85af86a0520a7f75","title":"谨慎使用Stream"},{"parent":"56d29cb10a9cd035","lineStyle":{"randomLineColor":"#FD5155"},"children":[{"parent":"64a4a6ccc9e50116","children":[],"id":"29694c8720b784e1","title":"在Stream中优先使用不影响原集合的方法，如filter、map、sorted等，等处理完数据后再通过收集器转化为对应容器"}],"id":"64a4a6ccc9e50116","title":"优先选择Stream中无副作用的函数"},{"parent":"56d29cb10a9cd035","lineStyle":{"randomLineColor":"#3D5EC2"},"children":[{"parent":"0f1c2cb13def1c23","children":[],"id":"d9f5c80203c812c3","title":"在某些场景下，后续需要使用Stream或迭代，Collection都兼容，优先返回Collection、List、Set"}],"id":"0f1c2cb13def1c23","title":"Stream优先返回Collection类型"},{"parent":"56d29cb10a9cd035","lineStyle":{"randomLineColor":"#BE49C4"},"children":[{"parent":"d8e00f51a56f98f2","children":[],"id":"9f8a4abab8217603","title":"并行能够加快程序运行速度，当可能带来线程不安全的一致性问题"},{"parent":"d8e00f51a56f98f2","children":[],"id":"03232e4c45a61519","title":"使用并行最好互不干扰，比如数组实现的容器（ArrayList、HashMap），线程各自负责自己的区间&nbsp;"},{"parent":"d8e00f51a56f98f2","children":[],"id":"eb52fd37719ff2a0","title":"使用 parallel 开启并行"}],"id":"d8e00f51a56f98f2","title":"谨慎使用Stream并行"}],"collapsed":true,"id":"56d29cb10a9cd035","_id":"root","title":"Lambda与Stream流"},{"parent":"root","lineStyle":{"lineType":"curve","underLine":true,"randomLineColor":"#0D7C82","lineWidth":3},"children":[{"parent":"e5d641011fbc2a59","lineStyle":{"randomLineColor":"#BE49C4"},"children":[{"parent":"73178ef0ec7d9b3a","children":[],"id":"645507d6cc164277","title":"必须在方法中检查入参，增加健壮性"},{"parent":"73178ef0ec7d9b3a","children":[],"id":"f21db08204d0db34","title":"不检查入参可能导致运行时抛出异常或得不到期望结果导致需要排查"}],"id":"73178ef0ec7d9b3a","title":"检查参数有效性"},{"parent":"e5d641011fbc2a59","lineStyle":{"randomLineColor":"#DD489D"},"children":[{"parent":"9f92d3165cdb8bb8","children":[{"parent":"444afa12a92c2eab","children":[],"id":"8b1c794ffdd5567d","title":"使用不可变对象代替"},{"parent":"444afa12a92c2eab","children":[],"id":"256b998f3b03cf27","title":"可变对象在入参依赖、方法响应时使用保护性拷贝，避免逃逸"}],"id":"444afa12a92c2eab","title":"依赖的可变对象发生逃逸导致得不到期望结果"}],"id":"9f92d3165cdb8bb8","title":"必要时进行保护性拷贝"},{"parent":"e5d641011fbc2a59","lineStyle":{"randomLineColor":"#F88A35"},"children":[{"parent":"8b9d5d69a903a25e","children":[],"id":"2f9b6fede95cca20","title":"见名知意"},{"parent":"8b9d5d69a903a25e","children":[],"id":"1c134272057b0bcd","title":"API不要追求提供便利的方法，这种方法应该在工具类中"},{"parent":"8b9d5d69a903a25e","children":[],"id":"ff5d5272865b999c","title":"避免参数过长"},{"parent":"8b9d5d69a903a25e","children":[],"id":"310c82fb34ba0a7a","title":"定义参数类型为接口而不是类"},{"parent":"8b9d5d69a903a25e","children":[],"id":"e126bd55326dfa6f","title":"对于boolean类型考虑使用泛型"}],"id":"8b9d5d69a903a25e","title":"谨慎设计方法"},{"parent":"e5d641011fbc2a59","lineStyle":{"randomLineColor":"#FD5155"},"children":[{"parent":"a17f14222b1652a2","children":[],"id":"154e622902a77ca2","title":"重载静态时确定"},{"parent":"a17f14222b1652a2","children":[],"id":"1abcca456be90c6c","title":"避免发现类型转换导致使用错重载方法，使用具体类型命名代替"},{"parent":"a17f14222b1652a2","children":[],"id":"4b3a73fde0e071e5","title":"一定要使用重载则重载中实现一致"}],"id":"a17f14222b1652a2","title":"慎用重载"},{"parent":"e5d641011fbc2a59","lineStyle":{"randomLineColor":"#0D7C82"},"children":[{"parent":"d0e9fcb86bdc7a06","children":[],"id":"e8d1d94ab056c70d","title":"无法预估参数长度才使用，有性能消耗（初始化数组）"},{"parent":"d0e9fcb86bdc7a06","children":[],"id":"c746ed3528b01da2","title":"方法实现考虑不传可变长参数的情况"}],"id":"d0e9fcb86bdc7a06","title":"慎用可变长参数"},{"parent":"e5d641011fbc2a59","lineStyle":{"randomLineColor":"#80BA4C"},"children":[{"parent":"0faa312932204a2c","children":[],"id":"360f0df7022eb97c","title":"空容器不会发生空指针"},{"parent":"0faa312932204a2c","children":[],"id":"4b79719db6ec11cf","title":"调用方要规范使用容器判空"}],"id":"0faa312932204a2c","title":"返回空容器而不是null"},{"parent":"e5d641011fbc2a59","lineStyle":{"randomLineColor":"#0FBAB0"},"children":[{"parent":"a1dd4217509bf272","children":[],"id":"98dabac7274c8eb9","title":"Optional能够判空时考虑多种情况：非空、为空默认值、为空抛出异常"},{"parent":"a1dd4217509bf272","children":[{"parent":"100041b68a2d224d","children":[],"id":"d1f47df08965a38d","title":"注重性能"},{"parent":"100041b68a2d224d","children":[],"id":"c42e052642dcca49","title":"基本包装类"},{"parent":"100041b68a2d224d","children":[],"id":"8bf8af77c814dbc1","title":"键值对、集合的泛型中"}],"id":"100041b68a2d224d","title":"不应该使用Optional"}],"id":"a1dd4217509bf272","title":"谨慎使用Optional"},{"parent":"e5d641011fbc2a59","lineStyle":{"randomLineColor":"#3D5EC2"},"children":[{"parent":"3c5a6edec6093cab","children":[],"id":"e4b180c216dec9c9","title":"重要API编写文档注释"}],"id":"3c5a6edec6093cab","title":"为所有导出API编写文档注释"}],"collapsed":true,"id":"e5d641011fbc2a59","_id":"root","title":"方法"},{"parent":"root","lineStyle":{"lineType":"curve","underLine":true,"randomLineColor":"#FD5155","lineWidth":3},"children":[{"parent":"5199bedef0484886","lineStyle":{"randomLineColor":"#3D5EC2"},"children":[{"parent":"dc1aa67cd54eee92","children":[],"id":"d3d647f65e86e7d2","title":"最好第一次使用再声明"},{"parent":"dc1aa67cd54eee92","children":[],"id":"f9eb8fd8d1aa1a79","title":"局部变量只在循环中时for循环优于while循环"},{"parent":"dc1aa67cd54eee92","children":[],"id":"e2c66535feaecb9f","title":"方法内部实现较多导致作用域太大可以拆分方法"}],"id":"dc1aa67cd54eee92","title":"将局部变量作用域最小化"},{"parent":"5199bedef0484886","lineStyle":{"randomLineColor":"#0FBAB0"},"children":[{"parent":"468a43b4d0059e92","children":[],"id":"e165897a2a82461c","title":"foreach是迭代器与for循环实现的语法糖，只展示元素屏蔽迭代器与索引"},{"parent":"468a43b4d0059e92","children":[],"id":"5baefe5b914450f9","title":"优先使用foreach，需要迭代器或索引才使用for循环"}],"id":"468a43b4d0059e92","title":"foreach优于for循环"},{"parent":"5199bedef0484886","lineStyle":{"randomLineColor":"#FA5465"},"children":[{"parent":"5b6343e0b2f0f047","children":[],"id":"2a6e1b5261598b22","title":"不要自己造轮子"},{"parent":"5b6343e0b2f0f047","children":[],"id":"340a44232e2c48c2","title":"类库性能更好"},{"parent":"5b6343e0b2f0f047","children":[],"id":"8edf5b32c4b51bf3","title":"类库随着版本迭代功能会齐全"},{"parent":"5b6343e0b2f0f047","children":[],"id":"dd66c92680ca8f68","title":"使用类库大家都熟悉，容易维护"}],"id":"5b6343e0b2f0f047","title":"了解和使用类库"},{"parent":"5199bedef0484886","lineStyle":{"randomLineColor":"#02ACF4"},"children":[{"parent":"285dfabbb92f1fd5","children":[],"id":"5be73c9d3e613aae","title":"浮点型计算会有精度溢出"},{"parent":"285dfabbb92f1fd5","children":[],"id":"e5d4da7e7ffb7cf9","title":"转换为最小单位使用整形计算"},{"parent":"285dfabbb92f1fd5","children":[],"id":"0cada994d6864d39","title":"必须有小数或超出整形范围使用bigdecimal计算"}],"id":"285dfabbb92f1fd5","title":"精确计算避免使用浮点型"},{"parent":"5199bedef0484886","lineStyle":{"randomLineColor":"#FCB52A"},"children":[{"parent":"b6c0b5912e4866bd","children":[{"parent":"d14c5b83e71668b8","children":[],"id":"a7c51c6b9db69014","title":"包装类可以值相同引用不同，比较使用==会导致错误结果，要使用equals"},{"parent":"d14c5b83e71668b8","children":[],"id":"48dc34238c5e5d1f","title":"包装类可以为Null"},{"parent":"d14c5b83e71668b8","children":[],"id":"9656a26432c487d1","title":"基本数据类型更省空间、时间"}],"id":"d14c5b83e71668b8","title":"区别"},{"parent":"b6c0b5912e4866bd","children":[],"id":"74238a4d2d1e3354","title":"基本数据类型、包装类混用会自动拆装箱，注意性能开销"},{"parent":"b6c0b5912e4866bd","children":[],"id":"74b66dc026fca78f","title":"使用集合、反射只能使用包装类，其他情况使用基本数据类型"}],"id":"b6c0b5912e4866bd","title":"基本数据类型优于包装类"},{"parent":"5199bedef0484886","lineStyle":{"randomLineColor":"#DD489D"},"children":[{"parent":"7e7b6b0f260feb64","children":[],"id":"e89c164ed3a31d96","title":"字符串适用于文本，如果其他类型数值、布尔、枚举等合适就使用合适的"},{"parent":"7e7b6b0f260feb64","children":[],"id":"5270be37319def07","title":"字符串可能占用很大的空间、时间"}],"id":"7e7b6b0f260feb64","title":"其他类型合适就避免使用字符串"},{"parent":"5199bedef0484886","lineStyle":{"randomLineColor":"#0F80C4"},"children":[{"parent":"6a85eb551898852f","children":[],"id":"43b8de9e2b74c4c0","title":"字符串String为不可变对象，拼接存在性能问题"},{"parent":"6a85eb551898852f","children":[],"id":"8c5ac828725e378c","title":"大量拼接使用StringBuilder、线程安全使用StringBuffer"}],"id":"6a85eb551898852f","title":"字符串拼接性能"},{"parent":"5199bedef0484886","lineStyle":{"randomLineColor":"#F88A35"},"children":[{"parent":"ada12b83ea8878b3","children":[],"id":"42a4b43d3942eeaf","title":"接口引用对象更加灵活，实现可以升级、替换"},{"parent":"ada12b83ea8878b3","children":[],"id":"e386e2811daddfc5","title":"没合适的接口类型，优先选择抽象、公共父类"}],"id":"ada12b83ea8878b3","title":"通过接口引用对象"},{"parent":"5199bedef0484886","lineStyle":{"randomLineColor":"#7549C5"},"children":[{"parent":"910e91ac08d8215a","children":[{"parent":"31680d755b53aff1","children":[],"id":"143279e48d4ee9b2","title":"失去编译类型检查"},{"parent":"31680d755b53aff1","children":[],"id":"0f54c2587480a828","title":"反射实现代码不好阅读"},{"parent":"31680d755b53aff1","children":[],"id":"09e0554380b6ef2f","title":"性能损耗"}],"id":"31680d755b53aff1","title":"缺点"},{"parent":"910e91ac08d8215a","children":[],"id":"ec31e10e6ef2807c","title":"反射能够实现服务提供者框架，在编译期间引用接口，而不需要实现类已经实现"}],"id":"910e91ac08d8215a","title":"谨慎使用反射"},{"parent":"5199bedef0484886","lineStyle":{"randomLineColor":"#0D7C82"},"children":[{"parent":"8b68ded64db68ba7","children":[],"id":"3f8ef1d440b2860c","title":"使用本地方法会丢失JVM分配内存、垃圾回收等好处，使用本地方法前要做好测试"}],"id":"8b68ded64db68ba7","title":"谨慎使用本地方法"},{"parent":"5199bedef0484886","lineStyle":{"randomLineColor":"#80BA4C"},"children":[{"parent":"28d3ce4a61d58a3b","children":[],"id":"d424cc90e7866d9c","title":"设计系统时考虑性能，不要为了优化破坏设计的合理结构"},{"parent":"28d3ce4a61d58a3b","children":[],"id":"4f3119a7a6331dbc","title":"完成系统后压测，分析性能瓶颈再解决"}],"id":"28d3ce4a61d58a3b","title":"谨慎进行优化"},{"parent":"5199bedef0484886","lineStyle":{"randomLineColor":"#FD5155"},"children":[{"parent":"bda5ceb3d95ec67d","children":[],"id":"f21a0908ffbc6be3","title":"遵守常规、通用、公认的命名规范，见名知意"}],"id":"bda5ceb3d95ec67d","title":"遵循普通接受的命名规范"}],"collapsed":true,"id":"5199bedef0484886","_id":"root","title":"通用编程"},{"parent":"root","lineStyle":{"lineType":"curve","underLine":true,"randomLineColor":"#0D7C82","lineWidth":3},"children":[{"parent":"69766d6d49503d44","lineStyle":{"randomLineColor":"#F88A35"},"children":[{"parent":"547f00815e91f408","children":[],"id":"524dab40867f6998","title":"不要使用异常来做程序的流程控制"},{"parent":"547f00815e91f408","children":[],"id":"de4133f7d59a3bea","title":"只有针对异常情况才使用异常"}],"id":"547f00815e91f408","title":"只针对异常情况才使用异常"},{"parent":"69766d6d49503d44","lineStyle":{"randomLineColor":"#0D7C82"},"children":[{"parent":"51da13dcf000ea8a","children":[],"id":"62d0ab5922426e98","title":"广泛的异常分为受检异常、运行时异常、错误"},{"parent":"51da13dcf000ea8a","children":[],"id":"c3472e757fbf4c19","title":"设计API遵循：可恢复的情况抛出受检异常让调用者处理，程序错误或不确定是否可恢复抛出运行时异常"}],"id":"51da13dcf000ea8a","title":"可恢复使用受检异常、程序错误使用运行时异常"},{"parent":"69766d6d49503d44","lineStyle":{"randomLineColor":"#0FBAB0"},"children":[{"parent":"ca32b35ca8c9431a","children":[],"id":"e903d473867daa46","title":"处理受检异常可以带来可靠，太多受检异常会导致复杂"},{"parent":"ca32b35ca8c9431a","children":[],"id":"5a9b936ff4b1b4b7","title":"不处理异常就不要catch 直接抛出、无法恢复就抛出运行时异常（业务异常）"}],"id":"ca32b35ca8c9431a","title":"避免不必要的受检异常"},{"parent":"69766d6d49503d44","lineStyle":{"randomLineColor":"#DD489D"},"children":[{"parent":"c44907eb1eaeb785","children":[],"id":"287ad922a29118bc","title":"优先复用已有的标准异常，不满足再自定义"}],"id":"c44907eb1eaeb785","title":"优先使用标准异常"},{"parent":"69766d6d49503d44","lineStyle":{"randomLineColor":"#02ACF4"},"children":[{"parent":"14937b79885945a1","children":[],"id":"2864d43b4adc3dfa","title":"设计抽象层次的方法时，关注抽象层的异常，而不是具体实现的异常"},{"parent":"14937b79885945a1","children":[],"id":"631f46922b8c0657","title":"捕获具体实现层的A异常，再抛出抽象层的B异常"}],"id":"14937b79885945a1","title":"抛出与抽象对应的异常"},{"parent":"69766d6d49503d44","lineStyle":{"randomLineColor":"#FA5465"},"children":[{"parent":"32db5403fd149d30","children":[],"id":"8015d8d0d0d61d4a","title":"方法使用throws说明可能抛出受检异常"},{"parent":"32db5403fd149d30","children":[],"id":"858b71ff5b805953","title":"避免抛出exception异常，要抛出具体的异常"},{"parent":"32db5403fd149d30","children":[],"id":"7263ae868d5611f8","title":"使用文档@throws说明可能抛出的受检/非受检异常"}],"id":"32db5403fd149d30","title":"方法抛出的异常建立文档"},{"parent":"69766d6d49503d44","lineStyle":{"randomLineColor":"#3D5EC2"},"children":[{"parent":"34d6fdfb61228bcf","children":[],"id":"6cdbaa9f1af3dd2b","title":"异常会存储字符串保留发生异常现场的关键信息"},{"parent":"34d6fdfb61228bcf","children":[],"id":"b156f4ca41ee68a9","title":"自定义异常时尽量构造出方便排查的关键信息"}],"id":"34d6fdfb61228bcf","title":"异常信息保留关键信息"},{"parent":"69766d6d49503d44","lineStyle":{"randomLineColor":"#7549C5"},"children":[{"parent":"cb64a9bb933597b4","children":[],"id":"d7a4541f5d7bf1dd","title":"异常失败可能导致对象状态不一致，从而导致数据不一致"},{"parent":"cb64a9bb933597b4","children":[{"parent":"c3be1ec56bd4c27a","children":[],"id":"0b340711dab3727c","title":"使用不可变对象"},{"parent":"c3be1ec56bd4c27a","children":[],"id":"1ef816ae6359c5e2","title":"检查入参，提前抛出异常"},{"parent":"c3be1ec56bd4c27a","children":[],"id":"ba10787d4284d79a","title":"调整执行顺序，把可能抛出异常的操作放在修改状态前"},{"parent":"c3be1ec56bd4c27a","children":[],"id":"1a19e9bb5de1fca8","title":"对源对象进行拷贝"},{"parent":"c3be1ec56bd4c27a","children":[],"id":"d2a85d5ade2fd22e","title":"实现回滚操作"}],"id":"c3be1ec56bd4c27a","title":"保证异常失败原子性"}],"id":"cb64a9bb933597b4","title":"努力让异常失败保持原子性"},{"parent":"69766d6d49503d44","lineStyle":{"randomLineColor":"#80BA4C"},"children":[{"parent":"2d69c967d95cac63","children":[],"id":"b84a092e013247e2","title":"忽略异常会导致程序继续执行导致错误发生，难以排查"}],"id":"2d69c967d95cac63","title":"不要忽略异常"}],"collapsed":true,"id":"69766d6d49503d44","_id":"root","title":"异常"},{"parent":"root","lineStyle":{"lineType":"curve","underLine":true,"randomLineColor":"#FCB52A","lineWidth":3},"children":[{"parent":"7e9f148a27db61d6","lineStyle":{"randomLineColor":"#DD489D"},"children":[{"parent":"594c54272b5c25bf","children":[],"id":"2d940958caef3e85","title":"并发读共享可变数据可以使用volatile，如果要写操作则使用同步手段如synchronized"}],"id":"594c54272b5c25bf","title":"同步访问共享可变数据"},{"parent":"7e9f148a27db61d6","lineStyle":{"randomLineColor":"#0FBAB0"},"children":[{"parent":"2d6cf3f786484dc2","children":[],"id":"afc621521c2a49e2","title":"过度使用同步会导致性能开销太大，在同步区域尽量少做操作"}],"id":"2d6cf3f786484dc2","title":"避免过度同步"},{"parent":"7e9f148a27db61d6","lineStyle":{"randomLineColor":"#F88A35"},"children":[{"parent":"89974dc94ca59be8","children":[],"id":"89c8e374aa4eb47f","title":"Executor框架分离任务与执行，使用池化技术管理线程，并行stream （fork join）都优于单独使用线程"}],"id":"89974dc94ca59be8","title":"Executor框架优于线程"},{"parent":"7e9f148a27db61d6","lineStyle":{"randomLineColor":"#0F80C4"},"children":[{"parent":"796d2f4d27efae97","children":[],"id":"8654c81b68529a7d","title":"并发包下的工具使用更简单，优于wait notify实现的等待通知"}],"id":"796d2f4d27efae97","title":"并发工具优于wait、notify"},{"parent":"7e9f148a27db61d6","lineStyle":{"randomLineColor":"#80BA4C"},"children":[{"parent":"97ba59be6132394f","children":[],"id":"045f41379b40826b","title":"当设计的类可能被并发调用时需要在文档上说明线程安全级别"},{"parent":"97ba59be6132394f","children":[{"parent":"f1e3b5099b6e131d","children":[],"id":"57db44c5f5edccd1","title":"不可变"},{"parent":"f1e3b5099b6e131d","children":[],"id":"52f9aa9bbbc21fe0","title":"绝对线程安全"},{"parent":"f1e3b5099b6e131d","children":[],"id":"705f6a44c2cb0f3e","title":"相对线程安全"},{"parent":"f1e3b5099b6e131d","children":[],"id":"0375e1c1f846ef1d","title":"线程不安全"}],"id":"f1e3b5099b6e131d","title":"线程安全级别"}],"id":"97ba59be6132394f","title":"线程安全性的文档化"},{"parent":"7e9f148a27db61d6","lineStyle":{"randomLineColor":"#FA5465"},"children":[{"parent":"a6c276d7340eb399","children":[],"id":"56900b90b6f89d09","title":"延迟初始化只是把初始化的开销放到第一次使用时再来初始化"},{"parent":"a6c276d7340eb399","children":[],"id":"c125bdcc228fbca4","title":"大多数情况下还是要直接初始化"},{"parent":"a6c276d7340eb399","children":[{"parent":"d937db214b0ea361","children":[],"id":"af951fcefcf799dd","title":"类加载保证只有一次初始化"},{"parent":"d937db214b0ea361","children":[],"id":"4ad47bbf54399db9","title":"双重检测保证只有一次初始化"}],"id":"d937db214b0ea361","title":"延迟初始化方式"}],"id":"a6c276d7340eb399","title":"谨慎延迟初始化"},{"parent":"7e9f148a27db61d6","lineStyle":{"randomLineColor":"#7549C5"},"children":[{"parent":"2e4e6b085fda095b","children":[],"id":"f9342135f8d15815","title":"Thread.yield 和 线程优先级 都依赖于线程调度器，依赖于线程调度器完成任务的程序是不可移植、不健壮的"}],"id":"2e4e6b085fda095b","title":"不要依赖于线程调度器"}],"collapsed":true,"id":"7e9f148a27db61d6","_id":"root","title":"并发"}],"root":true,"theme":"delicate_caihong","showWatermark":false,"id":"root","title":"Effective Java","version":343,"structure":"mind_free"}},"meta":{"exportTime":"2024-04-10 17:07:03","member":"","diagramInfo":{"creator":"","created":"2024-03-05 14:32:23","modified":"2024-04-08 13:45:22","title":"Effective Java","category":"mind_free"},"id":"65e6bc77bccbde6f27ad0019","type":"ProcessOn Schema File","version":"5.0"}}