## 逃逸分析带来的优化

### 逃逸

**对象不会发生逃逸: 对象的作用域只在某个方法,不会被外界调用到**



### 栈上分配内存

```java
//-Xms1G -Xmx1G -XX:+PrintGCDetails 
public class StackMemory {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        for (int i = 0; i < 10000000; i++) {
            memory();
        }

        System.out.println("花费时间:"+(System.currentTimeMillis()-start)+"ms");

        try {
            TimeUnit.SECONDS.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static void memory(){
        StackMemory memory = new StackMemory();
    }
}
```

-XX:-DoEscapeAnalysis 花费时间:63ms  (未开启逃逸分析)

-XX:+DoEscapeAnalysis 花费时间:4ms (开启逃逸分析)

**默认开启逃逸分析**



### 锁消除

同步加锁会带来开销

锁消除: 当加锁对象只作用某个方法时,JIT编译器借助逃逸分析判断 **使用的锁对象是不是只能被一个线程访问**,如果是这种情况下就不需要同步,可以取消这部分代码的同步,提高并发性能



### 标量替换

标量: 无法再分解的数据 (基本数据类型)

聚合量: 还可以再分解的数据 (对象)

**标量替换: JIT借助逃逸分析,该对象不发生逃逸,只作用于某个方法会把该对象(聚合量)拆成若干个成员变量(标量)来代替**

**默认开启标量替换**

```java
public class ScalarSubstitution {
    static class Man{
        int age;
        int id;

        public Man() {
        }
    }

    public static void createInstance(){
        Man man = new Man();
        man.id = 123;
        man.age = 321;
    }
    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        for (int i = 0; i < 10000000; i++) {
            createInstance();
        }

        System.out.println("花费时间:"+(System.currentTimeMillis()-start)+"ms");

        try {
            TimeUnit.SECONDS.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
//-Xmx200m -Xms200m -XX:+PrintGCDetails 
//-XX:+DoEscapeAnalysis 设置开启逃逸分析
//-XX:-EliminateAllocations 设置不开启标量替换 
//开启逃逸分析 + 关闭标量替换 : 花费时间:93ms
```

```java
//开启逃逸分析 + 开启标量替换  : 花费时间:6ms
```



